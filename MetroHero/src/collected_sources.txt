=== Source Collection Start ===

------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\main.c
[FILE NAME] main.c
------------------------------------------------------------

#include <windows.h>
#include "core/game.h"
#include "debug/debug.h"  // ★ 추가

int main(void) {

    // debug_console_info();

    game_run();
    return 0;
}


------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\core\game.c
[FILE NAME] game.c
------------------------------------------------------------

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>   // _getch
#include <ctype.h>   // tolower
#include "game.h"
#include "ui.h"
#include "../world/map.h"
#include "../entity/player.h"
#include "../world/glyph.h"  // ★ 추가

void game_run(void) {
    Map map;
    Player player;
    int prevX, prevY;  // ★ 이전 위치 저장

    map_init(&map, 1);
    player_init(&player);

    // ★ 스폰 포인트에 플레이어 배치
    player.x = map.spawnX;
    player.y = map.spawnY;

    ui_init();


    // ★ 초기 화면은 한 번만 그리기
    console_clear_fast();
    map_draw_at(&map, &player, 0, 0);

    // ★ 상태창 (상단)
    ui_draw_stats(&player, EQ_X, 0, EQ_W, 10);

    // ★ 장비창 (중간)
    ui_draw_equipment(&player, EQ_X, 10, EQ_W, 6);
    ui_draw_log(0, LOG_Y, LOG_W, LOG_H);

    // ★ 입력 안내는 초기에 한 번만 출력 (로그창 밖)
    console_goto(0, SCREEN_H - 1);
    printf("[화살표/WASD] 이동 | [Q] 종료");

    prevX = player.x;
    prevY = player.y;

    while (1) {
        int cmd = _getch();

        // ★ 화살표 키 처리 (2바이트 입력)
        if (cmd == 0 || cmd == 224) {  // 특수 키 감지
            cmd = _getch();  // 실제 키 코드 읽기

            switch (cmd) {
            case 72: cmd = 'w'; break;  // 위쪽 화살표
            case 80: cmd = 's'; break;  // 아래쪽 화살표
            case 75: cmd = 'a'; break;  // 왼쪽 화살표
            case 77: cmd = 'd'; break;  // 오른쪽 화살표
            }
        }

        cmd = tolower(cmd);

        if (cmd == 'q') break;

        player_move(&player, &map, cmd);

        if (prevX != player.x || prevY != player.y) {
            // 이전 위치를 원래 타일로 복원
            console_goto(prevX * 2, prevY);

            // ★ map.c의 tile_to_glyph를 public으로 만들고 재사용
            extern const char* tile_to_glyph(char t);  // map.h에 선언 추가
            printf("%s", tile_to_glyph(map.tiles[prevY][prevX]));

            // 새 위치 그리기
            console_goto(player.x * 2, player.y);
            printf(GLYPH_PLAYER);

            // ★ 로그창 갱신 추가
            ui_draw_log(0, LOG_Y, LOG_W, LOG_H);

            // ★ 입력 안내 다시 출력 (로그가 덮어쓸 수 있으므로)
            //console_goto(0, SCREEN_H - 1);
            //printf("[w,a,s,d] 이동 | [q] 종료");

            prevX = player.x;
            prevY = player.y;
        }
    }
}


------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\core\game.h
[FILE NAME] game.h
------------------------------------------------------------

#ifndef GAME_H
#define GAME_H

void game_run(void);

#endif


------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\core\ui.c
[FILE NAME] ui.c
------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include "ui.h"
#include "../entity/player.h"

void ui_init(void) {

    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);

    // 콘솔을 UTF-8로 설정
    SetConsoleOutputCP(CP_UTF8);
    SetConsoleCP(CP_UTF8);

    // ★ 순서 중요: 먼저 윈도우 크기를 최소로 줄임
    //SMALL_RECT minWindow = { 0, 0, 1, 1 };
    //SetConsoleWindowInfo(hOut, TRUE, &minWindow);

    //// ★ 그 다음 버퍼 크기 설정
    //COORD bufferSize = { SCREEN_W, SCREEN_H };
    //SetConsoleScreenBufferSize(hOut, bufferSize);

    //// ★ 마지막으로 윈도우 크기를 원하는 크기로 설정
    //SMALL_RECT windowSize = { 0, 0, SCREEN_W - 1, SCREEN_H - 1 };
    //SetConsoleWindowInfo(hOut, TRUE, &windowSize);

    // 커서 숨기기(선택)
    CONSOLE_CURSOR_INFO info;
    info.dwSize = 1;
    info.bVisible = FALSE;
    SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &info);
}

//void console_clear_fast(void) {
//    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
//    COORD pos = { 0, 0 };
//    SetConsoleCursorPosition(hOut, pos);
//}

void console_clear_fast(void) {
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);

    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(hOut, &csbi);

    DWORD cellCount = csbi.dwSize.X * csbi.dwSize.Y;
    DWORD count;
    COORD homeCoords = { 0, 0 };

    // 화면 전체를 공백으로 채우기
    FillConsoleOutputCharacter(hOut, ' ', cellCount, homeCoords, &count);

    // 화면 속성 리셋
    FillConsoleOutputAttribute(hOut, csbi.wAttributes, cellCount, homeCoords, &count);

    // 커서 위치 리셋
    SetConsoleCursorPosition(hOut, homeCoords);
}


void console_goto(int x, int y) {
    COORD pos = { x, y };
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos);
}


// 화면에 표시되는 실제 폭 계산 (한글 = 2칸, 영문 = 1칸)
static int display_width(const char* str) {
    int width = 0;
    const unsigned char* s = (const unsigned char*)str;

    while (*s) {
        if (*s < 128) {
            // ASCII (1바이트) = 1칸
            width += 1;
            s += 1;
        }
        else if ((*s & 0xE0) == 0xC0) {
            // UTF-8 2바이트 문자 = 2칸
            width += 2;
            s += 2;
        }
        else if ((*s & 0xF0) == 0xE0) {
            // UTF-8 3바이트 문자 (한글 등) = 2칸
            width += 2;
            s += 3;
        }
        else if ((*s & 0xF8) == 0xF0) {
            // UTF-8 4바이트 문자 = 2칸
            width += 2;
            s += 4;
        }
        else {
            s += 1;
        }
    }
    return width;
}

// ui.c에 추가

void ui_draw_stats(const Player* p, int x, int y, int w, int h) {
    console_goto(x, y);
    printf("┌─ 상태      ──────────┐");

    console_goto(x, y + 1);
    printf("│                      │");

    // HP 바 그리기 - 정확하게 맞추기
    console_goto(x, y + 2);
    printf("│ HP:");  // 'HP:' 까지 출력

    // HP 바 (10칸)
    int hpBars = (p->hp * 10) / p->maxHp;
    for (int i = 0; i < 10; i++) {
        if (i < hpBars)
            printf("█");
        else
            printf("░");
    }
    printf("        │");  // ★ 공백 7개

    // HP 수치
    console_goto(x, y + 3);
    printf("│     %3d / %3d        │", p->hp, p->maxHp);

    console_goto(x, y + 4);
    printf("│                      │");

    // 공격력
    console_goto(x, y + 5);
    printf("│ 공격력:  %3d         │", p->attack);

    // 방어력
    console_goto(x, y + 6);
    printf("│ 방어력:  %3d         │", p->defense);

    // 나머지 빈 공간
    for (int i = 7; i < h - 1; i++) {
        console_goto(x, y + i);
        printf("│                      │");
    }

    console_goto(x, y + h - 1);
    printf("└──────────────────────┘");
}

// ui_draw_equipment 수정 (높이 조정)
void ui_draw_equipment(const Player* p, int x, int y, int w, int h) {
    console_goto(x, y);
    printf("┌─ 장비      ──────────┐");

    console_goto(x, y + 1);
    printf("│                      │");

    console_goto(x, y + 2);
    printf("│ 무기:    %s", p->weaponName);
    int len = display_width(p->weaponName);
    for (int i = 0; i < 11 - len; i++) putchar(' ');
    printf(" │");

    console_goto(x, y + 3);
    printf("│ 방어구:  %s", p->armorName);
    len = display_width(p->armorName);
    for (int i = 0; i < 11 - len; i++) putchar(' ');
    printf(" │");

    console_goto(x, y + 4);
    printf("│ 아이템 : %s", p->item1);
    len = display_width(p->item1);
    for (int i = 0; i < 11 - len; i++) putchar(' ');
    printf(" │");

    console_goto(x, y + 5);
    printf("└──────────────────────┘");
}

#define LOG_LINES 200
char log_buf[LOG_LINES][128];
int log_index = 0;

void ui_add_log(const char* msg) {
    snprintf(log_buf[log_index], 128, "%s", msg);
    log_index = (log_index + 1) % LOG_LINES;
}

void ui_draw_log(int x, int y, int w, int h) {
    // 상단 테두리
    console_goto(x, y);
    printf("┌─ 대화  ");
    for (int i = 8; i < w - 2; i++) printf("─");
    printf("┐");

    int start = (log_index - (h - 2) + LOG_LINES) % LOG_LINES;

    // 로그 내용
    for (int i = 0; i < h - 2; i++) {
        console_goto(x, y + 1 + i);
        printf("│ ");

        char line[256] = { 0 };
        snprintf(line, sizeof(line), "%-*s", w - 4, log_buf[(start + i) % LOG_LINES]);
        line[w - 4] = '\0';
        printf("%s", line);

        printf(" │");
    }

    // 하단 테두리
    console_goto(x, y + h - 1);
    printf("└");
    for (int i = 1; i < w - 1; i++) printf("─");
    printf("┘");
}



------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\core\ui.h
[FILE NAME] ui.h
------------------------------------------------------------

#ifndef UI_H
#define UI_H

#include "../entity/player.h"

#define SCREEN_W 120
#define SCREEN_H 30

// 상단 전체 높이
#define TOP_H 20

// 맵 설정
//#define MAP_W 40                // 논리적 가로 칸 수
//#define MAP_H 20                // 맵 세로 수
//#define MAP_RENDER_W (MAP_W*2)  // 실제 출력되는 문자 폭 80

// ★ 맵 렌더링 최대 너비 (동적 크기 지원)
#define MAX_MAP_RENDER_W 100  // 최대값만 정의

// 장비창(오른쪽) - 고정 위치
#define EQ_X 80       // ★ 고정값으로 변경 (MAX_MAP_W * 2)
#define EQ_W (SCREEN_W - EQ_X)
#define EQ_H TOP_H

// 로그창(하단)
#define LOG_Y TOP_H
#define LOG_W SCREEN_W
#define LOG_H (SCREEN_H - TOP_H -1)


void console_goto(int x , int y);

void ui_draw_equipment(const Player* p , int x , int y , int w , int h);  // ★ 이 줄 확인
void ui_draw_stats(const Player* p , int x , int y , int w , int h);  // ★ 추가


void ui_add_log(const char* msg);
void ui_draw_log(int x , int y , int w , int h);

void console_clear_fast(void);

#endif


------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\debug\debug.c
[FILE NAME] debug.c
------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include "debug.h"

void debug_console_info(void) {
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);

    // ★ UTF-8 설정 먼저!
    SetConsoleOutputCP(CP_UTF8);
    SetConsoleCP(CP_UTF8);

    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(hOut, &csbi);

    printf("╔════════════════════════════════════╗\n");
    printf("║     콘솔 상태 디버깅 정보          ║\n");
    printf("╚════════════════════════════════════╝\n\n");

    printf("버퍼 크기:   %d x %d\n", csbi.dwSize.X, csbi.dwSize.Y);
    printf("윈도우 크기: %d x %d\n",
        csbi.srWindow.Right - csbi.srWindow.Left + 1,
        csbi.srWindow.Bottom - csbi.srWindow.Top + 1);
    printf("커서 위치:   (%d, %d)\n",
        csbi.dwCursorPosition.X, csbi.dwCursorPosition.Y);
    printf("\n윈도우 좌표:\n");
    printf("  Left=%d, Top=%d\n", csbi.srWindow.Left, csbi.srWindow.Top);
    printf("  Right=%d, Bottom=%d\n", csbi.srWindow.Right, csbi.srWindow.Bottom);

    printf("\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n");
    printf("아무 키나 누르면 계속...");
    _getch();
    printf("\n");
}

------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\debug\debug.h
[FILE NAME] debug.h
------------------------------------------------------------

#pragma once
#ifndef DEBUG_H
#define DEBUG_H

// 콘솔 상태 정보 출력
void debug_console_info(void);

// 게임 상태 정보 출력 (나중에 추가 가능)
// void debug_game_state(void);
// void debug_player_info(const Player* p);

#endif

------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\entity\player.c
[FILE NAME] player.c
------------------------------------------------------------

#include <stdio.h>

#include "../world/map.h"
#include "player.h"
#include "../core/ui.h"  // ★ ui_add_log 사용을 위해 추가

void player_init(Player* p) {
    // ★ 맵 크기를 알 수 없으므로 기본값 설정
    p->x = 20;  // 또는 map_init 후에 설정
    p->y = 10;

    // ★ 초기 스탯
    p->maxHp = 10;
    p->hp = 10;
    p->attack = 1;
    p->defense = 0;

    p->weaponName = "";
    p->armorName = "";
    p->item1 = "";
}


void player_move(Player* p, const Map* m, int cmd) {
    int nx = p->x;
    int ny = p->y;

    switch (cmd) {
    case 'w': ny--; break;
    case 's': ny++; break;
    case 'a': nx--; break;
    case 'd': nx++; break;
    }

    if (map_is_walkable(m, nx, ny)) {
        p->x = nx;
        p->y = ny;

        // 이동 성공 로그 찍기
        //char logMsg[128];
        //snprintf(logMsg, sizeof(logMsg), "이동: (%d, %d)", p->x, p->y);
		//ui_add_log(logMsg);
    }
}


------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\entity\player.h
[FILE NAME] player.h
------------------------------------------------------------

#ifndef PLAYER_H
#define PLAYER_H

struct Map; // Map 구조체의 전방 선언

typedef struct {
	int x, y;

	// ★ 스탯
	int hp;           // 현재 체력
	int maxHp;        // 최대 체력
	int attack;       // 공격력
	int defense;      // 방어력

	const char* weaponName;
	const char* armorName;
	const char* item1;
} Player;

void player_init(Player* p);
void player_move(Player* p, const struct Map* m, int cmd); // struct Map*로 명확히 선언

#endif


------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\world\glyph.h
[FILE NAME] glyph.h
------------------------------------------------------------

#ifndef GLYPH_H
#define GLYPH_H

// ========================
// 렌더링 문자 상수 정의
// ========================

// 맵 타일
#define GLYPH_FLOOR    "  "    // 바닥
#define GLYPH_WALL     "██"    // 벽
#define GLYPH_RAIL     "=="    // 철도 레일
#define GLYPH_EMPTY    "  "    // 빈 공간
#define GLYPH_DOOR     "++"    // 문
#define GLYPH_STAIRS   "▼▼"    // 계단

// 엔티티
#define GLYPH_PLAYER   "옷"    // 플레이어
#define GLYPH_ENEMY    "적"    // 적
#define GLYPH_NPC      "민"    // NPC
#define GLYPH_ITEM     "물"    // 아이템

// 기타
#define GLYPH_TREE     "♣♣"    // 나무
#define GLYPH_WATER    "≈≈"    // 물

// ========================
// 타일 문자 (맵 데이터용)
// ========================
#define TILE_FLOOR     '.'
#define TILE_WALL      '#'
#define TILE_RAIL      '='
#define TILE_DOOR      '+'
#define TILE_SPAWN     '@'     // ★ 스폰 포인트

#endif

------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\world\map.c
[FILE NAME] map.c
------------------------------------------------------------

#include <stdio.h>
#include <windows.h>
#include "map.h"
#include "../entity/player.h"
#include "../core/ui.h"   // ★ 반드시 필요
#include "map_data.h"  // ★ 추가
#include "glyph.h"  // ★ 추가

// 타일 문자를 렌더링 문자로 변환
const char* tile_to_glyph(char t) {
    switch (t) {
    case '.':
        return GLYPH_FLOOR;
    case '#':
        return GLYPH_WALL;
    case '=':
        return GLYPH_RAIL;
    case '+':
        return GLYPH_DOOR;
    case 'S':
        return GLYPH_STAIRS;
    default:
        return GLYPH_EMPTY;
    }
}

// ★ 스폰 포인트 찾기
void map_find_spawn(Map* m) {
    // 기본값 (중앙)
    m->spawnX = m->width / 2;
    m->spawnY = m->height / 2;

    // @ 찾기
    for (int y = 0; y < m->height; y++) {
        for (int x = 0; x < m->width; x++) {
            if (m->tiles[y][x] == '@') {
                m->spawnX = x;
                m->spawnY = y;
                // @ 를 일반 바닥으로 변환
                m->tiles[y][x] = '.';
                return;  // 첫 번째 @ 만 사용
            }
        }
    }
}

// -------------------------------
// 맵 초기화
// -------------------------------
void map_init(Map* m, int stageNumber) {
    m->stageNumber = stageNumber;  // ★ 선택사항
    load_map(m, stageNumber);
    map_find_spawn(m);  // ★ 이 줄 추가!
}

// -------------------------------
// 맵 렌더링
// -------------------------------
//void map_draw(const Map* m, const Player* p) {
//    for (int y = 0; y < MAP_H; y++) {
//        for (int x = 0; x < MAP_W; x++) {
//
//            if (p->x == x && p->y == y) {
//                // 플레이어 위치
//                printf(">>");   // 전각 플레이어 아이콘
//            }
//            else {
//                printf("%s", tile_to_glyph(m->tiles[y][x]));
//            }
//
//        }
//        putchar('\n');
//    }
//}

void map_draw_at(const Map* m, const Player* p, int startX, int startY) {
    for (int y = 0; y < m->height; y++) {
        console_goto(startX, startY + y);

        for (int x = 0; x < m->width; x++) {
            if (x == p->x && y == p->y)
                printf(GLYPH_PLAYER);  // ★ 상수 사용
            else
                printf("%s", tile_to_glyph(m->tiles[y][x]));
        }
    }
}





// -------------------------------
// 이동 가능 여부 검사
// -------------------------------
int map_is_walkable(const Map* m, int x, int y) {
    if (x < 0 || x >= m->width || y < 0 || y >= m->height)  // ★ 동적 크기 사용
        return 0;

    return (m->tiles[y][x] == '.');
}


------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\world\map.h
[FILE NAME] map.h
------------------------------------------------------------

#ifndef MAP_HEADER
#define MAP_HEADER

#include "../entity/player.h"

#define MAX_MAP_W 100  // 최대 크기만 정의
#define MAX_MAP_H 50

//#define MAP_W 40
//#define MAP_H 20

//typedef struct {
//    char tiles[MAP_H][MAP_W];
//} Map;

typedef struct {
	int width;
	int height;
	int stageNumber;  // ★ 현재 스테이지 번호 추가 (선택사항)
	int spawnX;  // ★ 스폰 위치 추가
	int spawnY;  // ★ 스폰 위치 추가
	char tiles[ MAX_MAP_H ][ MAX_MAP_W ];
} Map;

void map_init(Map* m , int stageNumber);  // ★ 인자 추가
void map_draw_at(const Map* m , const Player* p , int startX , int startY);
int map_is_walkable(const Map* m, int x, int y);
const char* tile_to_glyph(char t);  // ★ 추가
void map_find_spawn(Map* m);  // ★ 추가

#endif


------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\world\map_data.c
[FILE NAME] map_data.c
------------------------------------------------------------

#include "map_data.h"
#include <string.h>

// ========================
// 맵 데이터 정의 (상단에 모아두기)
// ========================

static const char* MAP_STAGE_1[] = {
    "########################################",
    "#@....##################...............#",
    "#.....#................................#",
    "#.....#.####...........#########.......#",
    "#.....#.#..#...........#.......#.......#",
    "#.......#..#############.......#.......#",
    "#.......#..................#####.......#",
    "#########..................#...........#",
    "#.........................##...........#",
    "#.......#####..........#####...........#",
    "#.......#...#..........#...............#",
    "#.......#...############...............#",
    "#.......#..............................#",
    "#.......#############..................#",
    "#.....................#................#",
    "#.....................#................#",
    "#.....................##################",
    "#......................................#",
    "#......................................#",
    "########################################"
};

static const char* MAP_STAGE_2[] = {
    "########################################",
    "#====================================..#",
    "#====================================..#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "########################################"
};

static const char* MAP_STAGE_3[] = {
    "####################",
    "#..................#",
    "#....####..........#",
    "#....#..#..........#",
    "#....####..........#",
    "#..................#",
    "#..................#",
    "#..................#",
    "#..................#",
    "####################"
};

static const char* MAP_DEFAULT[] = {
    "####################",
    "#..................#",
    "#..................#",
    "#..................#",
    "#..................#",
    "#..................#",
    "#..................#",
    "#..................#",
    "#..................#",
    "####################"
};

// ========================
// 로직 함수들
// ========================

// ★ 공통 로드 함수
static void load_map_from_data(Map* m, const char** mapData, int height) {
    m->height = height;
    m->width = strlen(mapData[0]);

    for (int y = 0; y < m->height; y++) {
        for (int x = 0; x < m->width && x < MAX_MAP_W; x++) {
            m->tiles[y][x] = mapData[y][x];
        }
    }
}

// ★ 스테이지 번호로 맵 로드
void load_map(Map* m, int stageNumber) {
    switch (stageNumber) {
    case 1:
        load_map_from_data(m, MAP_STAGE_1, sizeof(MAP_STAGE_1) / sizeof(MAP_STAGE_1[0]));
        break;
    case 2:
        load_map_from_data(m, MAP_STAGE_2, sizeof(MAP_STAGE_2) / sizeof(MAP_STAGE_2[0]));
        break;
    case 3:
        load_map_from_data(m, MAP_STAGE_3, sizeof(MAP_STAGE_3) / sizeof(MAP_STAGE_3[0]));
        break;
    default:
        load_map_from_data(m, MAP_DEFAULT, sizeof(MAP_DEFAULT) / sizeof(MAP_DEFAULT[0]));
        break;
    }
}

------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\world\map_data.h
[FILE NAME] map_data.h
------------------------------------------------------------

#ifndef MAP_DATA_H
#define MAP_DATA_H

#include "map.h"

// ★ 단일 함수로 변경
void load_map(Map* m , int stageNumber);

#endif

=== Source Collection End ===
