=== Source Collection Start ===

------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\main.c
[FILE NAME] main.c
------------------------------------------------------------

#include <windows.h>
#include "core/game.h"
#include "debug/debug.h"  // â˜… ì¶”ê°€

int main(void) {

    // debug_console_info();

    game_run();
    return 0;
}


------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\core\combat.c
[FILE NAME] combat.c
------------------------------------------------------------

// core/combat.c
#include <stdio.h>
#include <windows.h>  // Sleep ì‚¬ìš©

#include "combat.h"
#include "ui.h"
#include "../world/map.h"
#include "../world/glyph.h"  // â˜… ì¶”ê°€


// â˜… ì¸ì ‘ ì  ì²´í¬ ë° ë©”ì‹œì§€ (ì²´ë ¥ + ìˆœí™˜ ëŒ€ì‚¬ í¬í•¨)
void combat_check_nearby_enemy(Map* m, Player* p) {
    Enemy* e = map_get_adjacent_enemy(m, p->x, p->y);
    if (e == NULL) return;

    const char* direction = map_get_enemy_direction(m, p->x, p->y, e);

    // â˜… í˜„ì¬ ëŒ€ì‚¬ë¥¼ êº¼ë‚¸ë‹¤
    const char* line = e->dialogues[e->dialogueIndex];

    // â˜… ë‹¤ìŒ ì ‘ê·¼ ì‹œ ë‹¤ìŒ ëŒ€ì‚¬ ì¶œë ¥ë˜ë„ë¡ index ì¦ê°€ (ìˆœí™˜)
    e->dialogueIndex = (e->dialogueIndex + 1) % e->dialogueCount;

    char logMsg[512];
    snprintf(logMsg, sizeof(logMsg),
        "%s%sì— %sì´(ê°€) ì„œìˆë‹¤! (HP: %d/%d) %sã€Œ%sã€%s",
        COMBAT_DETECT,
        direction,
        e->name,
        e->hp, e->maxHp,

        e->dialogueColor,   // â˜… ëŒ€ì‚¬ ìƒ‰ê¹”
        line,                // â˜… ëŒ€ì‚¬ ë‚´ìš©
        COLOR_RESET          // â˜… ë¦¬ì…‹ì„ ë§¨ ë’¤ì— ê°•ì œ ë°°ì¹˜
    );

    ui_add_log(logMsg);
}

// â˜… ì „íˆ¬ ì‹œìŠ¤í…œ
void combat_attack_enemy(Player* p, Enemy* e, Map* m) {
    char logMsg[128];

    // â˜… ì „íˆ¬ ì´í™íŠ¸ í‘œì‹œ
    ui_draw_combat_effect(107, 2);  // ìƒíƒœì°½ ì˜¤ë¥¸ìª½

    // â˜…â˜…â˜… í”Œë ˆì´ì–´ ê³µê²© - ëœë¤ ë°ë¯¸ì§€ â˜…â˜…â˜…
    int playerAttack = p->attackMin + rand() % (p->attackMax - p->attackMin + 1);
    int playerDamage = playerAttack - e->defense;
    if (playerDamage < 1) playerDamage = 1;

    e->hp -= playerDamage;

    // â˜… ë°ì€ ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ê°•ì¡°
    snprintf(logMsg, sizeof(logMsg),
        COMBAT_ATTACK "âš” %së¥¼ ê³µê²©! " COMBAT_DAMAGE "%d ë°ë¯¸ì§€!" COLOR_RESET " (HP: %d/%d)",
        e->name, playerDamage, e->hp > 0 ? e->hp : 0, e->maxHp);
    ui_add_log(logMsg);

    // â˜… ì ê¹ ëŒ€ê¸° (íƒ€ê²©ê°)
    //Sleep(100);

    // ì  ì‚¬ë§ ì²´í¬
    if (e->hp <= 0) {
        e->isAlive = 0;
        // â˜… ë³´ë¼ìƒ‰ìœ¼ë¡œ ê°•ì¡°
        snprintf(logMsg, sizeof(logMsg),
            COMBAT_DEATH "â˜… %së¥¼ ì²˜ì¹˜í–ˆë‹¤! â˜…" COLOR_RESET, e->name);
        ui_add_log(logMsg);

        // â˜… ì´í™íŠ¸ ì œê±°
        ui_clear_combat_effect(107, 2);
        return;
    }

    // â˜… ì  ë°˜ê²© ì „ ì´í™íŠ¸ ë³€ê²½
    //ui_clear_combat_effect(107, 2);

    // ì  ë°˜ê²© ì´í™íŠ¸ (ë°©íŒ¨)
    //console_goto(107, 2);
    //printf(COLOR_BRIGHT_BLUE "  ğŸ›¡" COLOR_RESET);
    //console_goto(107, 3);
    //printf(COLOR_BRIGHT_BLUE " ğŸ›¡ğŸ›¡ğŸ›¡" COLOR_RESET);
    //console_goto(107, 4);
    //printf(COLOR_BRIGHT_BLUE "ğŸ›¡ğŸ›¡ğŸ›¡ğŸ›¡ğŸ›¡" COLOR_RESET);

    // â˜…â˜…â˜… ì  ë°˜ê²© - ëœë¤ ë°ë¯¸ì§€ â˜…â˜…â˜…
    int enemyAttack = e->attackMin + rand() % (e->attackMax - e->attackMin + 1);
    int enemyDamage = enemyAttack - p->defense;
    if (enemyDamage < 1) enemyDamage = 1;

    p->hp -= enemyDamage;

    // â˜… ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ê°•ì¡°
    snprintf(logMsg, sizeof(logMsg),
        COMBAT_ENEMY "â˜  %sì˜ ë°˜ê²©! " COMBAT_DAMAGE "%d ë°ë¯¸ì§€!" COLOR_RESET " (í”Œë ˆì´ì–´ HP: %d/%d)",
        e->name, enemyDamage, p->hp > 0 ? p->hp : 0, p->maxHp);
    ui_add_log(logMsg);

    //Sleep(100);

    // â˜… ì´í™íŠ¸ ì œê±°
    //ui_clear_combat_effect(107, 2);

    // í”Œë ˆì´ì–´ ì‚¬ë§ ì²´í¬
    if (p->hp <= 0) {
        ui_add_log("ë‹¹ì‹ ì€ ì“°ëŸ¬ì¡ŒìŠµë‹ˆë‹¤...");
    }
}

------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\core\combat.h
[FILE NAME] combat.h
------------------------------------------------------------

// core/combat.h
#ifndef COMBAT_H
#define COMBAT_H

#include "../entity/player.h"
#include "../entity/enemy.h"
#include "../world/map.h"

// ì¸ì ‘ ì  ì²´í¬ ë° ë©”ì‹œì§€ ìƒì„±
void combat_check_nearby_enemy(Map* m , Player* p);

// ì „íˆ¬ ì‹œì‘
void combat_attack_enemy(Player* p , Enemy* e , Map* m);

#endif

------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\core\game.c
[FILE NAME] game.c
------------------------------------------------------------

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>   // _getch
#include <ctype.h>   // tolower
#include "game.h"
#include "ui.h"
#include "../world/map.h"
#include "../entity/player.h"
#include "../world/glyph.h"  // â˜… ì¶”ê°€
#include "combat.h"  // â˜… ì¶”ê°€

void game_run(void) {
    Map map;
    Player player;
    int prevX, prevY;  // â˜… ì´ì „ ìœ„ì¹˜ ì €ì¥

    map_init(&map, 1);
    player_init(&player);

    // â˜… ìŠ¤í° í¬ì¸íŠ¸ì— í”Œë ˆì´ì–´ ë°°ì¹˜
    player.x = map.spawnX;
    player.y = map.spawnY;

    ui_init();


    // â˜… ì´ˆê¸° í™”ë©´ì€ í•œ ë²ˆë§Œ ê·¸ë¦¬ê¸°
    console_clear_fast();
    //map_draw_at(&map, &player, 0, 0);
    // ë·°í¬íŠ¸ êµ¬ì¡°ë¡œ ê°œì„ 
    map_draw_viewport(&map, &player, 0, 0, 60, 20);


    // â˜… ìƒíƒœì°½ (ìƒë‹¨)
    ui_draw_stats(&player, EQ_X, 0, EQ_W, 10);

    // â˜… ì¥ë¹„ì°½ (ì¤‘ê°„)
    ui_draw_equipment(&player, EQ_X, 10, EQ_W, 6);
    ui_draw_log(0, LOG_Y, LOG_W, LOG_H);

    // â˜… ì…ë ¥ ì•ˆë‚´ëŠ” ì´ˆê¸°ì— í•œ ë²ˆë§Œ ì¶œë ¥ (ë¡œê·¸ì°½ ë°–)
    console_goto(0, SCREEN_H - 1);
    printf("[í™”ì‚´í‘œ/WASD] ì´ë™ | [Q] ì¢…ë£Œ");

    prevX = player.x;
    prevY = player.y;

    while (1) {

        // â˜… í”Œë ˆì´ì–´ ì‚¬ë§ ì²´í¬
        if (player.hp <= 0) {
            ui_add_log("ê²Œì„ ì˜¤ë²„!");
            ui_draw_log(0, LOG_Y, LOG_W, LOG_H);
            console_goto(0, SCREEN_H - 1);
            printf("ì•„ë¬´ í‚¤ë‚˜ ëˆ„ë¥´ë©´ ì¢…ë£Œ...");
            _getch();
            break;
        }

        int cmd = _getch();

        // â˜… í™”ì‚´í‘œ í‚¤ ì²˜ë¦¬ (2ë°”ì´íŠ¸ ì…ë ¥)
        if (cmd == 0 || cmd == 224) {  // íŠ¹ìˆ˜ í‚¤ ê°ì§€
            cmd = _getch();  // ì‹¤ì œ í‚¤ ì½”ë“œ ì½ê¸°

            switch (cmd) {
            case 72: cmd = 'w'; break;  // ìœ„ìª½ í™”ì‚´í‘œ
            case 80: cmd = 's'; break;  // ì•„ë˜ìª½ í™”ì‚´í‘œ
            case 75: cmd = 'a'; break;  // ì™¼ìª½ í™”ì‚´í‘œ
            case 77: cmd = 'd'; break;  // ì˜¤ë¥¸ìª½ í™”ì‚´í‘œ
            }
        }

        cmd = tolower(cmd);

        if (cmd == 'q') break;

        // â˜… í–‰ë™ ì „ì— ì´í™íŠ¸ ì§€ìš°ê¸°
        ui_clear_combat_effect(107, 2);

        // â˜… ì´ë™ ì „ì— ëª©í‘œ ìœ„ì¹˜ì˜ ì  í™•ì¸
        int targetX = player.x;
        int targetY = player.y;

        switch (cmd) {
        case 'w': targetY--; break;
        case 's': targetY++; break;
        case 'a': targetX--; break;
        case 'd': targetX++; break;
        }

        Enemy* targetEnemy = map_get_enemy_at(&map, targetX, targetY);

        player_move(&player, &map, cmd);

        // â˜… ì „íˆ¬ê°€ ë°œìƒí–ˆê³  ì ì´ ì£½ì—ˆìœ¼ë©´ í™”ë©´ì—ì„œ ì§€ìš°ê¸°
        if (targetEnemy != NULL && !targetEnemy->isAlive) {
            console_goto(targetEnemy->x * 2, targetEnemy->y);
            printf("%s", tile_to_glyph(map.tiles[targetEnemy->y][targetEnemy->x]));
        }

        //if (prevX != player.x || prevY != player.y) {
        //    // â˜… ì´ì „ ìœ„ì¹˜ì— ì ì´ ìˆì—ˆëŠ”ì§€ í™•ì¸
        //    Enemy* prevEnemy = map_get_enemy_at(&map, prevX, prevY);

        //    // ì´ì „ ìœ„ì¹˜ ë³µì›
        //    console_goto(prevX * 2, prevY);
        //    if (prevEnemy != NULL) {
        //        // ì ì´ ìˆìœ¼ë©´ ì ì„ ë‹¤ì‹œ ê·¸ë¦¼
        //        printf("%s", enemy_to_glyph(prevEnemy->type));
        //    }
        //    else {
        //        // ë°”ë‹¥ íƒ€ì¼ ë³µì›
        //        printf("%s", tile_to_glyph(map.tiles[prevY][prevX]));
        //    }

        //    // ìƒˆ ìœ„ì¹˜ ê·¸ë¦¬ê¸°
        //    console_goto(player.x * 2, player.y);
        //    printf(GLYPH_PLAYER);

        //    prevX = player.x;
        //    prevY = player.y;
        //}

        if (prevX != player.x || prevY != player.y) {
            map_draw_viewport(&map, &player, 0, 0, 60, 20);
            prevX = player.x;
            prevY = player.y;
        }


        // â˜…â˜…â˜…â˜…â˜… ìƒì ì—´ê¸° ì²˜ë¦¬ (E í‚¤) â˜…â˜…â˜…â˜…â˜…
        if (cmd == 'e' || cmd == '0') {
            Chest* chest = map_get_adjacent_chest(&map, player.x, player.y);
            if (chest != NULL && !chest->isOpened) {

                chest->isOpened = 1;

                //// ì•„ì´í…œ ì ìš©
                //player.weaponName = chest->itemName;

                // â˜… ì•„ì´í…œ ì‹¤ì œ ì ìš©
                player_apply_item(&player, chest->itemType, chest->itemName);

                char msg[128];
                snprintf(msg, sizeof(msg),
                    COLOR_BRIGHT_YELLOW "ğŸ“¦ ìƒìë¥¼ ì—´ì—ˆë‹¤! â†’ %s íšë“!" COLOR_RESET,
                    chest->itemName);

                ui_add_log(msg);

                console_goto(chest->x * 2, chest->y);
                printf("%s", tile_to_glyph(map.tiles[chest->y][chest->x]));

                // UI ê°±ì‹ 
                ui_draw_equipment(&player, EQ_X, 10, EQ_W, 6);
            }
        }

        // â˜… ì¸ì ‘ ì  ì²´í¬
        combat_check_nearby_enemy(&map, &player);

        // â˜… ì¸ì ‘ ìƒì ì²´í¬ ì¶”ê°€ (ì—¬ê¸°!)
        Chest* nearChest = map_get_adjacent_chest(&map, player.x, player.y);
        if (nearChest != NULL && !nearChest->isOpened) {
            ui_add_log("ê°€ê¹Œìš´ ê³³ì— ìƒìê°€ ìˆë‹¤. [E] í‚¤ë¡œ ì—´ ìˆ˜ ìˆë‹¤.");
        }

        // â˜… ìƒíƒœì°½ ê°±ì‹  (HP ë³€ê²½ ë°˜ì˜)
        ui_draw_stats(&player, EQ_X, 0, EQ_W, 10);

        // â˜… ë¡œê·¸ì°½ ê°±ì‹ 
        ui_draw_log(0, LOG_Y, LOG_W, LOG_H);
    }
}


------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\core\game.h
[FILE NAME] game.h
------------------------------------------------------------

#ifndef GAME_H
#define GAME_H

void game_run(void);

#endif


------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\core\ui.c
[FILE NAME] ui.c
------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include "ui.h"
#include "../entity/player.h"
#include "../world/glyph.h"

void ui_init(void) {

    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);

    // ì½˜ì†”ì„ UTF-8ë¡œ ì„¤ì •
    SetConsoleOutputCP(CP_UTF8);
    SetConsoleCP(CP_UTF8);

    // â˜…â˜…â˜… ANSI ìƒ‰ìƒ í™œì„±í™” (ì´ ë¶€ë¶„ì´ ê¼­ í•„ìš”!) â˜…â˜…â˜…
    DWORD dwMode = 0;
    GetConsoleMode(hOut, &dwMode);
    dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
    SetConsoleMode(hOut, dwMode);

    // â˜… ìˆœì„œ ì¤‘ìš”: ë¨¼ì € ìœˆë„ìš° í¬ê¸°ë¥¼ ìµœì†Œë¡œ ì¤„ì„
    //SMALL_RECT minWindow = { 0, 0, 1, 1 };
    //SetConsoleWindowInfo(hOut, TRUE, &minWindow);

    //// â˜… ê·¸ ë‹¤ìŒ ë²„í¼ í¬ê¸° ì„¤ì •
    //COORD bufferSize = { SCREEN_W, SCREEN_H };
    //SetConsoleScreenBufferSize(hOut, bufferSize);

    //// â˜… ë§ˆì§€ë§‰ìœ¼ë¡œ ìœˆë„ìš° í¬ê¸°ë¥¼ ì›í•˜ëŠ” í¬ê¸°ë¡œ ì„¤ì •
    //SMALL_RECT windowSize = { 0, 0, SCREEN_W - 1, SCREEN_H - 1 };
    //SetConsoleWindowInfo(hOut, TRUE, &windowSize);

    // ì»¤ì„œ ìˆ¨ê¸°ê¸°(ì„ íƒ)
    CONSOLE_CURSOR_INFO info;
    info.dwSize = 1;
    info.bVisible = FALSE;
    SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &info);
}

//void console_clear_fast(void) {
//    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
//    COORD pos = { 0, 0 };
//    SetConsoleCursorPosition(hOut, pos);
//}

void console_clear_fast(void) {
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);

    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(hOut, &csbi);

    DWORD cellCount = csbi.dwSize.X * csbi.dwSize.Y;
    DWORD count;
    COORD homeCoords = { 0, 0 };

    // í™”ë©´ ì „ì²´ë¥¼ ê³µë°±ìœ¼ë¡œ ì±„ìš°ê¸°
    FillConsoleOutputCharacter(hOut, ' ', cellCount, homeCoords, &count);

    // í™”ë©´ ì†ì„± ë¦¬ì…‹
    FillConsoleOutputAttribute(hOut, csbi.wAttributes, cellCount, homeCoords, &count);

    // ì»¤ì„œ ìœ„ì¹˜ ë¦¬ì…‹
    SetConsoleCursorPosition(hOut, homeCoords);
}


void console_goto(int x, int y) {
    COORD pos = { x, y };
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos);
}


// í™”ë©´ì— í‘œì‹œë˜ëŠ” ì‹¤ì œ í­ ê³„ì‚° (í•œê¸€ = 2ì¹¸, ì˜ë¬¸ = 1ì¹¸)
int display_width(const char* str) {
    int width = 0;
    const unsigned char* s = (const unsigned char*)str;

    while (*s) {
        // â˜… ANSI ì´ìŠ¤ì¼€ì´í”„ ì‹œí€€ìŠ¤ ê±´ë„ˆë›°ê¸°
        if (*s == '\033' || *s == 0x1B) {  // ESC ë¬¸ì
            s++;
            if (*s == '[') {  // CSI ì‹œí€€ìŠ¤ ì‹œì‘
                s++;
                // 'm'ì„ ë§Œë‚  ë•Œê¹Œì§€ ê±´ë„ˆë›°ê¸°
                while (*s && *s != 'm') {
                    s++;
                }
                if (*s == 'm') s++;
            }
            continue;
        }

        if (*s < 128) {
            // ASCII (1ë°”ì´íŠ¸) = 1ì¹¸
            width += 1;
            s += 1;
        }
        else if ((*s & 0xE0) == 0xC0) {
            // UTF-8 2ë°”ì´íŠ¸ ë¬¸ì = 2ì¹¸
            width += 2;
            s += 2;
        }
        else if ((*s & 0xF0) == 0xE0) {
            // UTF-8 3ë°”ì´íŠ¸ ë¬¸ì (í•œê¸€ ë“±) = 2ì¹¸
            width += 2;
            s += 3;
        }
        else if ((*s & 0xF8) == 0xF0) {
            // UTF-8 4ë°”ì´íŠ¸ ë¬¸ì = 2ì¹¸
            width += 2;
            s += 4;
        }
        else {
            s += 1;
        }
    }
    return width;
}

// ui.cì— ì¶”ê°€

void ui_draw_stats(const Player* p, int x, int y, int w, int h) {
    console_goto(x, y);
    printf("â”Œâ”€ ìƒíƒœ      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”");

    console_goto(x, y + 1);
    printf("â”‚                      â”‚");

    // HP ë°” ê·¸ë¦¬ê¸°
    console_goto(x, y + 2);
    printf("â”‚ HP:");
    int hpBars = (p->hp * 10) / p->maxHp;
    for (int i = 0; i < 10; i++) {
        if (i < hpBars)
            printf("â–ˆ");
        else
            printf("â–‘");
    }
    printf("        â”‚");

    // HP ìˆ˜ì¹˜
    console_goto(x, y + 3);
    printf("â”‚     %3d / %3d        â”‚", p->hp, p->maxHp);

    console_goto(x, y + 4);
    printf("â”‚                      â”‚");

    // â˜… ê³µê²©ë ¥ ë²”ìœ„ í‘œì‹œ
    console_goto(x, y + 5);
    printf("â”‚ ê³µê²©ë ¥: %2d~%2d        â”‚", p->attackMin, p->attackMax);

    // ë°©ì–´ë ¥
    console_goto(x, y + 6);
    printf("â”‚ ë°©ì–´ë ¥:  %3d         â”‚", p->defense);

    // ë‚˜ë¨¸ì§€ ë¹ˆ ê³µê°„
    for (int i = 7; i < h - 1; i++) {
        console_goto(x, y + i);
        printf("â”‚                      â”‚");
    }

    console_goto(x, y + h - 1);
    printf("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜");
}

// ui_draw_equipment ìˆ˜ì • (ë†’ì´ ì¡°ì •)
void ui_draw_equipment(const Player* p, int x, int y, int w, int h) {
    console_goto(x, y);
    printf("â”Œâ”€ ì¥ë¹„      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”");

    console_goto(x, y + 1);
    printf("â”‚                      â”‚");

    console_goto(x, y + 2);
    printf("â”‚ ë¬´ê¸°:    %s", p->weaponName);
    int len = display_width(p->weaponName);
    for (int i = 0; i < 11 - len; i++) putchar(' ');
    printf(" â”‚");

    console_goto(x, y + 3);
    printf("â”‚ ë°©ì–´êµ¬:  %s", p->armorName);
    len = display_width(p->armorName);
    for (int i = 0; i < 11 - len; i++) putchar(' ');
    printf(" â”‚");

    console_goto(x, y + 4);
    printf("â”‚ ì•„ì´í…œ : %s", p->item1);
    len = display_width(p->item1);
    for (int i = 0; i < 11 - len; i++) putchar(' ');
    printf(" â”‚");

    console_goto(x, y + 5);
    printf("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜");
}

#define LOG_LINES 200
char log_buf[LOG_LINES][256];
int log_index = 0;

void ui_add_log(const char* msg) {
    snprintf(log_buf[log_index], sizeof(log_buf[log_index]), "%s", msg);
    log_index = (log_index + 1) % LOG_LINES;
}

//void ui_draw_log(int x, int y, int w, int h) {
//    // ìƒë‹¨ í…Œë‘ë¦¬
//    console_goto(x, y);
//    printf("â”Œâ”€ ëŒ€í™”  ");
//    for (int i = 8; i < w - 2; i++) printf("â”€");
//    printf("â”");
//
//    int start = (log_index - (h - 2) + LOG_LINES) % LOG_LINES;
//
//    // ë¡œê·¸ ë‚´ìš©
//    for (int i = 0; i < h - 2; i++) {
//        console_goto(x, y + 1 + i);
//        printf("â”‚ ");
//
//        const char* logText = log_buf[(start + i) % LOG_LINES];
//        printf("%s", logText);
//
//        // â˜… ì˜¤ë¥¸ìª½ â”‚ ì œê±° - ê³µë°±ìœ¼ë¡œ ë‚¨ì€ ì¤„ ì „ë¶€ ë®ê¸°
//        int displayLen = display_width(logText);
//        int remaining = w - 2 - displayLen;  // "â”‚ " = 2ì¹¸ë§Œ ê³ ë ¤
//
//        for (int j = 0; j < remaining; j++) {
//            printf(" ");
//        }
//
//        //// â˜… í™”ë©´ í‘œì‹œ í­ ì •í™•íˆ ê³„ì‚°
//        //int displayLen = display_width(logText);
//        //int contentWidth = w - 4;  // "â”‚ " + " â”‚" = 4ì¹¸
//        //int remaining = contentWidth - displayLen;
//
//        //// â˜… ë‚¨ì€ ê³µê°„ì„ ê³µë°±ìœ¼ë¡œ ì±„ìš°ê¸°
//        //for (int j = 0; j < remaining; j++) {
//        //    printf(" ");
//        //}
//
//        //printf(" â”‚");
//    }
//
//    // í•˜ë‹¨ í…Œë‘ë¦¬
//    console_goto(x, y + h - 1);
//    printf("â””");
//    for (int i = 1; i < w - 1; i++) printf("â”€");
//    printf("â”˜");
//}

void ui_draw_log(int x, int y, int w, int h) {
    // ìƒë‹¨ í…Œë‘ë¦¬
    console_goto(x, y);
    printf("â”Œâ”€ ëŒ€í™”  ");
    for (int i = 8; i < w - 2; i++) printf("â”€");
    printf("â”");

    int start = (log_index - (h - 2) + LOG_LINES) % LOG_LINES;

    // ë¡œê·¸ ë‚´ìš©
    for (int i = 0; i < h - 2; i++) {
        console_goto(x, y + 1 + i);
        printf("â”‚ ");

        const char* logText = log_buf[(start + i) % LOG_LINES];
        printf("%s", logText);

        // â˜… ë‚¨ì€ ê³µê°„ì„ ê³µë°±ìœ¼ë¡œ ì±„ìš°ê¸°
        int displayLen = display_width(logText);
        int contentWidth = w - 4;  // "â”‚ " + " â”‚" = 4ì¹¸
        int remaining = contentWidth - displayLen;

        for (int j = 0; j < remaining + 1; j++) {
            printf(" ");
        }

        printf("â”‚");
    }

    // í•˜ë‹¨ í…Œë‘ë¦¬
    console_goto(x, y + h - 1);
    printf("â””");
    for (int i = 1; i < w - 1; i++) printf("â”€");
    printf("â”˜");
}

// ui.cì— ì¶”ê°€
void ui_draw_combat_effect(int x, int y) {

    // â˜… ì „íˆ¬ì¤‘ í…ìŠ¤íŠ¸ (ì¹¼ ì´í™íŠ¸ ìœ„)
    console_goto(x, y - 1);
    printf(COLOR_BRIGHT_RED "ì „íˆ¬ì¤‘" COLOR_RESET);

    // ê¸°ì¡´ ì¹¼ ëª¨ì–‘
    console_goto(x, y);
    printf(COLOR_BRIGHT_RED "  âš”" COLOR_RESET);

    console_goto(x, y + 1);
    printf(COLOR_BRIGHT_RED " âš”âš”âš”" COLOR_RESET);

    console_goto(x, y + 2);
    printf(COLOR_BRIGHT_RED "âš”âš”âš”âš”âš”" COLOR_RESET);

    console_goto(x, y + 3);
    printf(COLOR_BRIGHT_RED " âš”âš”âš”" COLOR_RESET);

    console_goto(x, y + 4);
    printf(COLOR_BRIGHT_RED "  âš”" COLOR_RESET);
}

void ui_clear_combat_effect(int x, int y) {

    // â˜… "ì „íˆ¬ì¤‘" ì§€ìš°ê¸°
    console_goto(x, y - 1);
    printf("      ");   // "ì „íˆ¬ì¤‘" 3ê¸€ì = UTF-8 6ì¹¸

    // ê¸°ì¡´ ì¹¼ ì´í™íŠ¸ ì§€ìš°ê¸°
    for (int i = 0; i < 5; i++) {
        console_goto(x, y + i);
        printf("       ");
    }
}



------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\core\ui.h
[FILE NAME] ui.h
------------------------------------------------------------

#ifndef UI_H
#define UI_H

#include "../entity/player.h"

#define SCREEN_W 120
#define SCREEN_H 30

// ìƒë‹¨ ì „ì²´ ë†’ì´
#define TOP_H 20

// ë§µ ì„¤ì •
//#define MAP_W 40                // ë…¼ë¦¬ì  ê°€ë¡œ ì¹¸ ìˆ˜
//#define MAP_H 20                // ë§µ ì„¸ë¡œ ìˆ˜
//#define MAP_RENDER_W (MAP_W*2)  // ì‹¤ì œ ì¶œë ¥ë˜ëŠ” ë¬¸ì í­ 80

// â˜… ë§µ ë Œë”ë§ ìµœëŒ€ ë„ˆë¹„ (ë™ì  í¬ê¸° ì§€ì›)
#define MAX_MAP_RENDER_W 100  // ìµœëŒ€ê°’ë§Œ ì •ì˜

// ì¥ë¹„ì°½(ì˜¤ë¥¸ìª½) - ê³ ì • ìœ„ì¹˜
#define EQ_X 80       // â˜… ê³ ì •ê°’ìœ¼ë¡œ ë³€ê²½ (MAX_MAP_W * 2)
#define EQ_W (SCREEN_W - EQ_X)
#define EQ_H TOP_H

// ë¡œê·¸ì°½(í•˜ë‹¨)
#define LOG_Y TOP_H
#define LOG_W SCREEN_W
#define LOG_H (SCREEN_H - TOP_H -1)


void console_goto(int x , int y);

void ui_draw_equipment(const Player* p , int x , int y , int w , int h);  // â˜… ì´ ì¤„ í™•ì¸
void ui_draw_stats(const Player* p , int x , int y , int w , int h);  // â˜… ì¶”ê°€


void ui_add_log(const char* msg);
void ui_draw_log(int x , int y , int w , int h);

void console_clear_fast(void);

void ui_draw_combat_effect(int x , int y);  // ì „íˆ¬ ì´í™íŠ¸
void ui_clear_combat_effect(int x , int y); // ì´í™íŠ¸ ì œê±°

#endif


------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\debug\debug.c
[FILE NAME] debug.c
------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include "debug.h"

void debug_console_info(void) {
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);

    // â˜… UTF-8 ì„¤ì • ë¨¼ì €!
    SetConsoleOutputCP(CP_UTF8);
    SetConsoleCP(CP_UTF8);

    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(hOut, &csbi);

    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘     ì½˜ì†” ìƒíƒœ ë””ë²„ê¹… ì •ë³´          â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");

    printf("ë²„í¼ í¬ê¸°:   %d x %d\n", csbi.dwSize.X, csbi.dwSize.Y);
    printf("ìœˆë„ìš° í¬ê¸°: %d x %d\n",
        csbi.srWindow.Right - csbi.srWindow.Left + 1,
        csbi.srWindow.Bottom - csbi.srWindow.Top + 1);
    printf("ì»¤ì„œ ìœ„ì¹˜:   (%d, %d)\n",
        csbi.dwCursorPosition.X, csbi.dwCursorPosition.Y);
    printf("\nìœˆë„ìš° ì¢Œí‘œ:\n");
    printf("  Left=%d, Top=%d\n", csbi.srWindow.Left, csbi.srWindow.Top);
    printf("  Right=%d, Bottom=%d\n", csbi.srWindow.Right, csbi.srWindow.Bottom);

    printf("\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n");
    printf("ì•„ë¬´ í‚¤ë‚˜ ëˆ„ë¥´ë©´ ê³„ì†...");
    _getch();
    printf("\n");
}

------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\debug\debug.h
[FILE NAME] debug.h
------------------------------------------------------------

#pragma once
#ifndef DEBUG_H
#define DEBUG_H

// ì½˜ì†” ìƒíƒœ ì •ë³´ ì¶œë ¥
void debug_console_info(void);

// ê²Œì„ ìƒíƒœ ì •ë³´ ì¶œë ¥ (ë‚˜ì¤‘ì— ì¶”ê°€ ê°€ëŠ¥)
// void debug_game_state(void);
// void debug_player_info(const Player* p);

#endif

------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\entity\chest.c
[FILE NAME] chest.c
------------------------------------------------------------

#include "chest.h"

void chest_init(Chest* c, int x, int y, const char* itemType, const char* itemName) {
    c->x = x;
    c->y = y;
    c->isOpened = 0;
    c->itemType = itemType;
    c->itemName = itemName;
}


------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\entity\chest.h
[FILE NAME] chest.h
------------------------------------------------------------

#pragma once
#ifndef CHEST_H
#define CHEST_H

typedef struct {
	int x , y;
	int isOpened;          // 0 = ë‹«í˜, 1 = ì´ë¯¸ ì—´ë¦° ìƒì

	const char* itemType;  // "weapon", "armor", "item"
	const char* itemName;  // íšë“í•  ì•„ì´í…œ ì´ë¦„
} Chest;

void chest_init(Chest* c , int x , int y , const char* itemType , const char* itemName);

#endif


------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\entity\enemy.c
[FILE NAME] enemy.c
------------------------------------------------------------

#include <stdio.h>
#include "enemy.h"
#include "../world/glyph.h"


void enemy_init(Enemy* e, char type, int x, int y) {
    e->type = type;
    e->x = x;
    e->y = y;
    e->isAlive = 1;

    // íƒ€ì…ë³„ ìŠ¤íƒ¯ ì„¤ì •
    switch (type) {
    case 'a': { // ê³ ë¸”ë¦°

        // â˜… enemy_init ë‚´ë¶€ì— ëŒ€ì‚¬ ì •ì˜
        static const char* lines[] = {
            "ë‚˜ëŠ” ì”ì¸í•œ ëƒ¥ì½”ë‹¤ì˜¹",
            "ëƒ¥ì½”ëƒ¥ì½” ëŒ€ì „ìŸ"
        };

        e->name = "ë§¹í˜¹í•œê³ ì–‘ì´";
        e->maxHp = 5;
        e->hp = 5;
        //e->attack = 2;

        e->attackMin = 1;  // â˜… 1~3 ë°ë¯¸ì§€
        e->attackMax = 3;

        e->defense = 0;
        e->dialogues = lines;   // â˜… ë°°ì—´ ì—°ê²°
        e->dialogueCount = sizeof(lines) / sizeof(lines[0]);
        e->dialogueIndex = 0;   // â˜… ìµœì´ˆ index ì„¤ì •
        e->dialogueColor = COLOR_BRIGHT_CYAN;
        break;
    }
    case 'b': { // ê²€ì€ê´´ë¬¼

        static const char* lines[] = {
            "ì „ì² ì—­ ë‚´ ì¹¨ì…ìë¥¼ ì¸ì‹í–ˆìŠµë‹ˆë‹¤...",
            "ê²½ê³ : ë¹„ì¸ê°€ ì¸ì›ì…ë‹ˆë‹¤.",
            "ëŒì•„ê°€ë¼ ë‚  ê±´ë“¤ë©´ í›„íšŒí• ê²ƒì´ë‹¤"
        };

        e->name = "ê²½ë¹„ë¡œë´‡";
        e->maxHp = 10;
        e->hp = 10;
        //e->attack = 3;

        e->attackMin = 100;  // â˜… 2~4 ë°ë¯¸ì§€
        e->attackMax = 100;

        e->defense = 0;

        e->dialogues = lines;
        e->dialogueCount = sizeof(lines) / sizeof(lines[0]);
        e->dialogueIndex = 0;
        e->dialogueColor = COLOR_RED;
        break;

    }

    default: {  // ì•Œ ìˆ˜ ì—†ëŠ” íƒ€ì…

        static const char* lines[] = {
            "í‚¤ì—ì—ì—ì—‘!",
            "ìœ¼ë¥´ë¥´ë¥´ë¥´â€¦",
            "ë¼ì•„ì•„ì•…!"
        };

        e->name = "ëª¬ìŠ¤í„°";
        e->maxHp = 3;
        e->hp = 3;
        //e->attack = 1;

        e->attackMin = 1;
        e->attackMax = 2;

        e->defense = 0;

        e->dialogues = lines;
        e->dialogueCount = sizeof(lines) / sizeof(lines[0]);
        e->dialogueIndex = 0;
        e->dialogueColor = COLOR_YELLOW;
        break;
    }
    }
}

int enemy_is_at(const Enemy* e, int x, int y) {
    return (e->isAlive && e->x == x && e->y == y);
}

------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\entity\enemy.h
[FILE NAME] enemy.h
------------------------------------------------------------

#ifndef ENEMY_H
#define ENEMY_H

#define MAX_ENEMIES 50  // ë§µë‹¹ ìµœëŒ€ ì  ìˆ˜

typedef struct {
	int x , y;           // ìœ„ì¹˜
	char type;          // 'a' = ê³ ë¸”ë¦°, 'b' = ì˜¤í¬ ë“±
	int hp;
	int maxHp;
	//int attack;

	// â˜… ê³µê²©ë ¥ì„ ë²”ìœ„ë¡œ ë³€ê²½
	int attackMin;
	int attackMax;

	int defense;
	int isAlive;        // 1 = ì‚´ì•„ìˆìŒ, 0 = ì£½ìŒ
	const char* name;   // "ê³ ë¸”ë¦°", "ì˜¤í¬" ë“±
	const char** dialogues;  // â˜… ëŒ€ì‚¬ ë°°ì—´ (ë¬¸ìì—´ ë°°ì—´)
	int dialogueCount;       // â˜… ì´ ëª‡ ê°œ?
	int dialogueIndex;       // â˜… í˜„ì¬ ì–´ë–¤ ëŒ€ì‚¬ë¥¼ ì¶œë ¥í• ì§€
	const char* dialogueColor;   // â˜… ì¶”ê°€: ëŒ€ì‚¬ ìƒ‰ê¹”
} Enemy;

// ì  ì´ˆê¸°í™” (íƒ€ì…ì— ë”°ë¼ ìŠ¤íƒ¯ ì„¤ì •)
void enemy_init(Enemy* e , char type , int x , int y);

// ì ì´ í•´ë‹¹ ìœ„ì¹˜ì— ìˆëŠ”ì§€ í™•ì¸
int enemy_is_at(const Enemy* e , int x , int y);

#endif#pragma once


------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\entity\player.c
[FILE NAME] player.c
------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>  // â˜… rand() ì‚¬ìš©
#include <time.h>    // â˜… time() ì‚¬ìš©

#include "../world/map.h"
#include "player.h"
#include "../core/ui.h"  // â˜… ui_add_log ì‚¬ìš©ì„ ìœ„í•´ ì¶”ê°€
#include "../core/combat.h"  // â˜… ì¶”ê°€

void player_init(Player* p) {
    // â˜… ë§µ í¬ê¸°ë¥¼ ì•Œ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ê¸°ë³¸ê°’ ì„¤ì •
    p->x = 20;  // ë˜ëŠ” map_init í›„ì— ì„¤ì •
    p->y = 10;

    // â˜… ì´ˆê¸° ìŠ¤íƒ¯
    p->maxHp = 10;
    p->hp = 10;
    //p->attack = 3;

    // â˜… ê³µê²©ë ¥ ë²”ìœ„ ì„¤ì •
    p->attackMin = 2;
    p->attackMax = 5;

    p->defense = 0;

    p->weaponName = "";
    p->armorName = "";
    p->item1 = "";
}


void player_move(Player* p, const Map* m, int cmd) {
    int nx = p->x;
    int ny = p->y;

    switch (cmd) {
    case 'w': ny--; break;
    case 's': ny++; break;
    case 'a': nx--; break;
    case 'd': nx++; break;
    }

    // â˜… ëª©í‘œ ìœ„ì¹˜ì— ì ì´ ìˆëŠ”ì§€ í™•ì¸
    Enemy* targetEnemy = map_get_enemy_at((Map*)m, nx, ny);

    if (targetEnemy != NULL) {
        // â˜… ì ì´ ìˆìœ¼ë©´ ì „íˆ¬!
        combat_attack_enemy(p, targetEnemy, (Map*)m);
        return;  // ì´ë™í•˜ì§€ ì•ŠìŒ
    }

    // ì¼ë°˜ ì´ë™
    if (map_is_walkable(m, nx, ny)) {
        p->x = nx;
        p->y = ny;
    }
}

void player_apply_item(Player* p, const char* itemType, const char* itemName) {

    // ======== ë¬´ê¸° ì ìš© ========
    if (strcmp(itemType, "weapon") == 0) {
        p->weaponName = itemName;

        // ë¬´ê¸° ì¢…ë¥˜ë³„ ëŠ¥ë ¥ì¹˜ ì„¤ì •
        if (strcmp(itemName, "ì´ˆë³´ì ê²€") == 0) {
            p->attackMin = 1000;
            p->attackMax = 10000;
        }
        else if (strcmp(itemName, "ê°•ì²  ê²€") == 0) {
            p->attackMin = 20;
            p->attackMax = 150;
        }
        else if (strcmp(itemName, "ë§ˆë ¥ì˜ ê²€") == 0) {
            p->attackMin = 50;
            p->attackMax = 200;
        }

        ui_add_log("ë¬´ê¸°ë¥¼ ì¥ì°©í–ˆë‹¤!");
        return;
    }

    // ======== ë°©ì–´êµ¬ ì ìš© ========
    if (strcmp(itemType, "armor") == 0) {
        p->armorName = itemName;

        if (strcmp(itemName, "ê°€ì£½ ê°‘ì˜·") == 0)
            p->defense = 2;
        else if (strcmp(itemName, "ì²  ê°‘ì˜·") == 0)
            p->defense = 5;
        else if (strcmp(itemName, "ë§ˆë‚˜ ê°‘ì˜·") == 0)
            p->defense = 10;

        ui_add_log("ë°©ì–´êµ¬ë¥¼ ì°©ìš©í–ˆë‹¤!");
        return;
    }

    // ======== ì•„ì´í…œ ì ìš© (ì˜êµ¬ ë²„í”„ ë²„ì „) ========
    if (strcmp(itemType, "item") == 0) {
        if (strcmp(itemName, "HP í¬ì…˜") == 0) {
            p->hp += 10;
            if (p->hp > p->maxHp) p->hp = p->maxHp;
        }
        else if (strcmp(itemName, "í˜ì˜ ë¬¼ì•½") == 0) {
            p->attackMin += 2;
            p->attackMax += 2;
        }
        else if (strcmp(itemName, "ë¯¼ì²©ì˜ ë¬¼ì•½") == 0) {
            p->defense += 1;
        }

        ui_add_log("ì•„ì´í…œ íš¨ê³¼ê°€ ì ìš©ë˜ì—ˆë‹¤!");
        return;
    }
}


------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\entity\player.h
[FILE NAME] player.h
------------------------------------------------------------

#ifndef PLAYER_H
#define PLAYER_H

struct Map;

typedef struct {
	int x , y;

	int hp;
	int maxHp;
	//int attack;

	// â˜… ê³µê²©ë ¥ì„ ë²”ìœ„ë¡œ ë³€ê²½
	int attackMin;
	int attackMax;

	int defense;

	const char* weaponName;
	const char* armorName;
	const char* item1;
} Player;

void player_init(Player* p);
void player_move(Player* p , struct Map* m , int cmd);  // â˜… const ì œê±°

#endif

------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\world\glyph.h
[FILE NAME] glyph.h
------------------------------------------------------------

#ifndef GLYPH_H
#define GLYPH_H

// ========================
// ë Œë”ë§ ë¬¸ì ìƒìˆ˜ ì •ì˜
// ========================

// ========================
// ANSI ìƒ‰ìƒ ì½”ë“œ
// ========================
#define COLOR_RESET   "\033[0m"
#define COLOR_BLACK   "\033[30m"
#define COLOR_RED     "\033[31m"
#define COLOR_GREEN   "\033[32m"
#define COLOR_YELLOW  "\033[33m"
#define COLOR_BLUE    "\033[34m"
#define COLOR_MAGENTA "\033[35m"
#define COLOR_CYAN    "\033[36m"
#define COLOR_WHITE   "\033[37m"

// ë°ì€ ìƒ‰ìƒ
#define COLOR_BRIGHT_BLACK   "\033[90m"
#define COLOR_BRIGHT_RED     "\033[91m"
#define COLOR_BRIGHT_GREEN   "\033[92m"
#define COLOR_BRIGHT_YELLOW  "\033[93m"
#define COLOR_BRIGHT_BLUE    "\033[94m"
#define COLOR_BRIGHT_MAGENTA "\033[95m"
#define COLOR_BRIGHT_CYAN    "\033[96m"
#define COLOR_BRIGHT_WHITE   "\033[97m"

// ë°°ê²½ìƒ‰
#define BG_BLACK   "\033[40m"
#define BG_RED     "\033[41m"
#define BG_GREEN   "\033[42m"
#define BG_YELLOW  "\033[43m"
#define BG_BLUE    "\033[44m"
#define BG_MAGENTA "\033[45m"
#define BG_CYAN    "\033[46m"
#define BG_WHITE   "\033[47m"

// ì „íˆ¬ ë©”ì‹œì§€ìš© ìƒ‰ìƒ
#define COMBAT_ATTACK    COLOR_BRIGHT_RED      // ê³µê²© (ë°ì€ ë¹¨ê°•)
#define COMBAT_DAMAGE    COLOR_BRIGHT_YELLOW   // ë°ë¯¸ì§€ (ë°ì€ ë…¸ë‘)
#define COMBAT_DEATH     COLOR_BRIGHT_MAGENTA  // ì²˜ì¹˜ (ë°ì€ ë³´ë¼)
#define COMBAT_ENEMY     COLOR_RED             // ì  ë°˜ê²© (ë¹¨ê°•)
#define COMBAT_DETECT    COLOR_CYAN            // ì  ë°œê²¬ (ì²­ë¡)

// ë§µ íƒ€ì¼
#define GLYPH_FLOOR    "  "    // ë°”ë‹¥
//#define GLYPH_WALL     COLOR_YELLOW "â–ˆâ–ˆ" COLOR_RESET    // â˜… ë…¸ë€ìƒ‰ ë²½
#define GLYPH_WALL     "\033[48;5;220m  \033[0m"  // ë…¸ë€ ë°°ê²½ë§Œ
//#define GLYPH_WALL     "\033[48;5;220m\033[38;5;234mË… \033[0m"
#define GLYPH_RAIL     "=="    // ì² ë„ ë ˆì¼
#define GLYPH_EMPTY    "  "    // ë¹ˆ ê³µê°„
#define GLYPH_DOOR     "++"    // ë¬¸
#define GLYPH_STAIRS   "â–¼â–¼"    // ê³„ë‹¨

// ì—”í‹°í‹°
#define GLYPH_PLAYER   COLOR_BRIGHT_GREEN "ì˜·" COLOR_RESET    // ë°ì€ ë…¹ìƒ‰
#define GLYPH_DOG      "ğŸˆâ€"    // â˜… ê³ ë¸”ë¦° ì¶”ê°€
#define GLYPH_ORC      "ì˜·"    // ë‚˜ì¤‘ì— ì‚¬ìš©
#define GLYPH_NPC      "ë¯¼"    // NPC
#define GLYPH_ITEM     "ë¬¼"    // ì•„ì´í…œ

#define GLYPH_CHEST  "ğŸ“¦"

// ê¸°íƒ€
#define GLYPH_TREE     "â™£â™£"    // ë‚˜ë¬´
#define GLYPH_WATER    "â‰ˆâ‰ˆ"    // ë¬¼

// ========================
// íƒ€ì¼ ë¬¸ì (ë§µ ë°ì´í„°ìš©)
// ========================
#define TILE_FLOOR     '.'
#define TILE_WALL      '#'
#define TILE_RAIL      '='
#define TILE_DOOR      '+'
#define TILE_SPAWN     '@'     // â˜… ìŠ¤í° í¬ì¸íŠ¸

// â˜… ì  íƒ€ì¼
#define TILE_GOBLIN    'a'
#define TILE_ORC       'b'

#endif

------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\world\map.c
[FILE NAME] map.c
------------------------------------------------------------

#include <stdio.h>
#include <windows.h>
#include "map.h"
#include "../entity/player.h"
#include "../entity/enemy.h"  // â˜… ì¶”ê°€
#include "../core/ui.h"   // â˜… ë°˜ë“œì‹œ í•„ìš”
#include "map_data.h"  // â˜… ì¶”ê°€
#include "glyph.h"  // â˜… ì¶”ê°€

// íƒ€ì¼ ë¬¸ìë¥¼ ë Œë”ë§ ë¬¸ìë¡œ ë³€í™˜
const char* tile_to_glyph(char t) {
    switch (t) {
    case '.':
        return GLYPH_FLOOR;
    //case '#':
    //    return GLYPH_WALL;
    case '#':
        return GLYPH_WALL;  // ë‹¨ì¼ íŒ¨í„´
    case '=':
        return GLYPH_RAIL;
    case '+':
        return GLYPH_DOOR;
    case 'S':
        return GLYPH_STAIRS;
    default:
        return GLYPH_EMPTY;
    }
}

// â˜… ì  íƒ€ì¼ì„ ë Œë”ë§ ë¬¸ìë¡œ ë³€í™˜
const char* enemy_to_glyph(char type) {
    switch (type) {
    case 'a':
        return GLYPH_DOG;
    case 'b':
        return GLYPH_ORC;
    default:
        return "??";
    }
}

// â˜… ìŠ¤í° í¬ì¸íŠ¸ ì°¾ê¸°
void map_find_spawn(Map* m) {
    // ê¸°ë³¸ê°’ (ì¤‘ì•™)
    m->spawnX = m->width / 2;
    m->spawnY = m->height / 2;

    // @ ì°¾ê¸°
    for (int y = 0; y < m->height; y++) {
        for (int x = 0; x < m->width; x++) {
            if (m->tiles[y][x] == '@') {
                m->spawnX = x;
                m->spawnY = y;
                // @ ë¥¼ ì¼ë°˜ ë°”ë‹¥ìœ¼ë¡œ ë³€í™˜
                m->tiles[y][x] = '.';
                return;  // ì²« ë²ˆì§¸ @ ë§Œ ì‚¬ìš©
            }
        }
    }
}

int is_enemy_tile(char t) {
    return (t == 'a' || t == 'b');   // ëª¬ìŠ¤í„° ëª©ë¡ ì§€ì •
}

// â˜… ë§µì—ì„œ ì  ì°¾ì•„ì„œ ì´ˆê¸°í™”
void map_load_enemies(Map* m) {
    m->enemyCount = 0;

    for (int y = 0; y < m->height; y++) {
        for (int x = 0; x < m->width; x++) {
            char tile = m->tiles[y][x];

            // a~z ë²”ìœ„ì˜ ì  íƒ€ì¼ ì°¾ê¸°
            if (is_enemy_tile(tile)) {
                if (m->enemyCount < MAX_ENEMIES) {
                    enemy_init(&m->enemies[m->enemyCount], tile, x, y);
                    m->enemyCount++;

                    // ì ì´ ìˆë˜ ìë¦¬ëŠ” ë°”ë‹¥ìœ¼ë¡œ ë³€ê²½
                    m->tiles[y][x] = '.';
                }
            }
        }
    }
}

// â˜… íŠ¹ì • ìœ„ì¹˜ì— ìˆëŠ” ì  ë°˜í™˜
Enemy* map_get_enemy_at(Map* m, int x, int y) {
    for (int i = 0; i < m->enemyCount; i++) {
        if (enemy_is_at(&m->enemies[i], x, y)) {
            return &m->enemies[i];
        }
    }
    return NULL;
}

void map_load_chests(Map* m) {
    m->chestCount = 0;

    int cfgCount = 0;
    const ChestConfig* cfg = get_chest_config(m->stageNumber, &cfgCount);

    if (cfg == NULL) return;

    for (int y = 0; y < m->height; y++) {
        for (int x = 0; x < m->width; x++) {

            char tile = m->tiles[y][x];

            // ìƒì íƒ€ì¼ì´ ì•„ë‹Œ ê²½ìš° skip
            if (tile < 'A' || tile > 'Z') continue;

            // í•´ë‹¹ tileì˜ config ì°¾ê¸°
            for (int i = 0; i < cfgCount; i++) {
                if (cfg[i].tile == tile) {

                    chest_init(
                        &m->chests[m->chestCount],
                        x, y,
                        cfg[i].itemType,
                        cfg[i].itemName
                    );
                    m->chestCount++;

                    //m->tiles[y][x] = '.'; // ìƒì íƒ€ì¼ì„ ë°”ë‹¥ìœ¼ë¡œ ë³€ê²½
                    break;
                }
            }
        }
    }
}






// -------------------------------
// ë§µ ë Œë”ë§
// -------------------------------
//void map_draw(const Map* m, const Player* p) {
//    for (int y = 0; y < MAP_H; y++) {
//        for (int x = 0; x < MAP_W; x++) {
//
//            if (p->x == x && p->y == y) {
//                // í”Œë ˆì´ì–´ ìœ„ì¹˜
//                printf(">>");   // ì „ê° í”Œë ˆì´ì–´ ì•„ì´ì½˜
//            }
//            else {
//                printf("%s", tile_to_glyph(m->tiles[y][x]));
//            }
//
//        }
//        putchar('\n');
//    }
//}

void map_draw_at(const Map* m, const Player* p, int startX, int startY) {
    for (int y = 0; y < m->height; y++) {
        console_goto(startX, startY + y);

        for (int x = 0; x < m->width; x++) {

            // 1) í”Œë ˆì´ì–´
            if (x == p->x && y == p->y) {
                printf(GLYPH_PLAYER);
                continue;
            }

            // 2) ì 
            Enemy* enemy = map_get_enemy_at((Map*)m, x, y);
            if (enemy != NULL) {
                printf("%s", enemy_to_glyph(enemy->type));
                continue;
            }

            // 3) â˜…â˜…â˜… ìƒì(Chest) ì²´í¬ â€” ì—¬ê¸° ìƒˆë¡œ ì¶”ê°€í•˜ëŠ” ë¶€ë¶„ â˜…â˜…â˜…
            Chest* chest = map_get_chest_at((Map*)m, x, y);
            if (chest != NULL && !chest->isOpened) {
                printf(GLYPH_CHEST);   // ì˜ˆ: ğŸ“¦
                continue;
            }

            // 4) ê¸°ë³¸ íƒ€ì¼
            printf("%s", tile_to_glyph(m->tiles[y][x]));
        }
    }
}

int map_is_walkable(const Map* m, int x, int y) {
    if (x < 0 || x >= m->width || y < 0 || y >= m->height)
        return 0;

    char t = m->tiles[y][x];

    // â˜… ìƒì(A~Z)ëŠ” ì´ë™ ë¶ˆê°€
    if (t >= 'A' && t <= 'Z')
        return 0;

    return (t == '.');
}


// â˜… í”Œë ˆì´ì–´ ì£¼ë³€(ìƒí•˜ì¢Œìš°)ì— ì ì´ ìˆëŠ”ì§€ í™•ì¸
Enemy* map_get_adjacent_enemy(Map* m, int px, int py) {
    // ìƒí•˜ì¢Œìš° 4ë°©í–¥ ì²´í¬
    int directions[4][2] = {
        {0, -1},  // ìœ„
        {0, 1},   // ì•„ë˜
        {-1, 0},  // ì™¼ìª½
        {1, 0}    // ì˜¤ë¥¸ìª½
    };

    for (int i = 0; i < 4; i++) {
        int nx = px + directions[i][0];
        int ny = py + directions[i][1];

        Enemy* enemy = map_get_enemy_at(m, nx, ny);
        if (enemy != NULL) {
            return enemy;
        }
    }

    return NULL;
}

// â˜… ì ì´ ì–´ëŠ ë°©í–¥ì— ìˆëŠ”ì§€ ë°˜í™˜
const char* map_get_enemy_direction(Map* m, int px, int py, Enemy* enemy) {
    if (enemy->x < px) return "ì™¼ìª½";
    if (enemy->x > px) return "ì˜¤ë¥¸ìª½";
    if (enemy->y < py) return "ìœ„";
    if (enemy->y > py) return "ì•„ë˜";
    return "ì—¬ê¸°";
}

Chest* map_get_chest_at(Map* m, int x, int y) {
    for (int i = 0; i < m->chestCount; i++) {
        if (!m->chests[i].isOpened &&
            m->chests[i].x == x && m->chests[i].y == y) {

            return &m->chests[i];
        }
    }
    return NULL;
}

Chest* map_get_adjacent_chest(Map* m, int px, int py) {
    int dirs[4][2] = {
        {0,-1}, {0,1}, {-1,0}, {1,0}
    };

    for (int i = 0; i < 4; i++) {
        int nx = px + dirs[i][0];
        int ny = py + dirs[i][1];

        Chest* chest = map_get_chest_at(m, nx, ny);
        if (chest != NULL) return chest;
    }

    return NULL;
}


// -------------------------------
// ë§µ ì´ˆê¸°í™”
// -------------------------------
void map_init(Map* m, int stageNumber) {
    m->stageNumber = stageNumber;  // â˜… ì„ íƒì‚¬í•­
    load_map(m, stageNumber);

    map_find_spawn(m);  // â˜… ì´ ì¤„ ì¶”ê°€!
    //map_load_enemies(m);  // â˜… ì´ ì¤„ ì¶”ê°€!

    map_load_enemies(m);
    map_load_chests(m);
}


void map_draw_viewport(const Map* m, const Player* p,
    int startX, int startY,
    int viewW, int viewH)
{
    // í”Œë ˆì´ì–´ ì¤‘ì‹¬ ë·° ê³„ì‚°
    int viewX = p->x - viewW / 2;
    int viewY = p->y - viewH / 2;

    // ë§µ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ë©´ í´ë¨í”„
    if (viewX < 0) viewX = 0;
    if (viewY < 0) viewY = 0;
    if (viewX + viewW > m->width)  viewX = m->width - viewW;
    if (viewY + viewH > m->height) viewY = m->height - viewH;
    if (viewX < 0) viewX = 0;
    if (viewY < 0) viewY = 0;

    for (int sy = 0; sy < viewH; sy++) {
        int my = viewY + sy;

        console_goto(startX, startY + sy);

        for (int sx = 0; sx < viewW; sx++) {
            int mx = viewX + sx;

            // ë§µ ë²”ìœ„ ë°–ì´ë©´ ê³µë°±
            if (mx < 0 || mx >= m->width ||
                my < 0 || my >= m->height)
            {
                printf("  ");
                continue;
            }

            // í”Œë ˆì´ì–´ ì¶œë ¥
            if (mx == p->x && my == p->y) {
                printf(GLYPH_PLAYER);
                continue;
            }

            // ì  ì¶œë ¥
            Enemy* enemy = map_get_enemy_at((Map*)m, mx, my);
            if (enemy != NULL) {
                printf("%s", enemy_to_glyph(enemy->type));
                continue;
            }

            // ìƒì ì¶œë ¥
            Chest* chest = map_get_chest_at((Map*)m, mx, my);
            if (chest != NULL && !chest->isOpened) {
                printf(GLYPH_CHEST);
                continue;
            }

            // ê¸°ë³¸ íƒ€ì¼ ì¶œë ¥
            printf("%s", tile_to_glyph(m->tiles[my][mx]));
        }
    }
}


------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\world\map.h
[FILE NAME] map.h
------------------------------------------------------------

#ifndef MAP_HEADER
#define MAP_HEADER

#include "../entity/player.h"
#include "../entity/enemy.h"  // â˜… ì¶”ê°€
#include "../entity/chest.h"

#define MAX_MAP_W 200  // ìµœëŒ€ í¬ê¸°ë§Œ ì •ì˜
#define MAX_MAP_H 120

//#define MAP_W 40
//#define MAP_H 20

//typedef struct {
//    char tiles[MAP_H][MAP_W];
//} Map;

#define MAX_CHESTS 50

typedef struct {
	int width;
	int height;
	int stageNumber;  // â˜… í˜„ì¬ ìŠ¤í…Œì´ì§€ ë²ˆí˜¸ ì¶”ê°€ (ì„ íƒì‚¬í•­)
	int spawnX;  // â˜… ìŠ¤í° ìœ„ì¹˜ ì¶”ê°€
	int spawnY;  // â˜… ìŠ¤í° ìœ„ì¹˜ ì¶”ê°€
	char tiles[ MAX_MAP_H ][ MAX_MAP_W ];

	// â˜… ì  ê´€ë¦¬
	Enemy enemies[ MAX_ENEMIES ];
	int enemyCount;

	Chest chests[ MAX_CHESTS ];
	int chestCount;
} Map;

void map_init(Map* m , int stageNumber);  // â˜… ì¸ì ì¶”ê°€
void map_draw_at(const Map* m , const Player* p , int startX , int startY);
int map_is_walkable(const Map* m, int x, int y);
const char* tile_to_glyph(char t);  // â˜… ì¶”ê°€
void map_find_spawn(Map* m);  // â˜… ì¶”ê°€
void map_load_enemies(Map* m);  // â˜… ì¶”ê°€
Enemy* map_get_enemy_at(Map* m , int x , int y);  // â˜… ì¶”ê°€
Enemy* map_get_adjacent_enemy(Map* m , int px , int py);  // â˜… ì¶”ê°€
const char* map_get_enemy_direction(Map* m , int px , int py , Enemy* enemy);  // â˜… ì¶”ê°€
const char* enemy_to_glyph(char type);

Chest* map_get_chest_at(Map* m , int x , int y);
Chest* map_get_adjacent_chest(Map* m , int px , int py);

void map_draw_viewport(const Map* m , const Player* p , int startX , int startY ,
	int viewW , int viewH);

#endif


------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\world\map_data.c
[FILE NAME] map_data.c
------------------------------------------------------------

#include "map_data.h"
#include <string.h>

// ========================
// ìŠ¤í…Œì´ì§€ë³„ ìƒì ì„¤ì •
// ========================

// Stage 1 : A~E ìƒì ë‚´ìš©
static const ChestConfig STAGE1_CHESTS[] = {
    {'A', "weapon", "ì´ˆë³´ì ê²€"},
    {'B', "armor",  "ê°€ì£½ ê°‘ì˜·"},
    {'C', "item",   "HP í¬ì…˜"},
    {'D', "item",   "ë¯¼ì²©ì˜ ë¬¼ì•½"},
    {'E', "item",   "í˜ì˜ ë¬¼ì•½"},
};
static const int STAGE1_CHEST_COUNT = sizeof(STAGE1_CHESTS) / sizeof(STAGE1_CHESTS[0]);

// Stage 2
static const ChestConfig STAGE2_CHESTS[] = {
    {'A', "weapon", "ê°•ì²  ê²€"},
    {'B', "armor",  "ì²  ê°‘ì˜·"},
    {'C', "item",   "ëŒ€í˜• HP í¬ì…˜"},
    {'D', "item",   "ìŠ¤íƒœë¯¸ë„ˆ ë¬¼ì•½"},
    {'E', "item",   "ì‹ ë¹„í•œ ì›ì„"},
};
static const int STAGE2_CHEST_COUNT = sizeof(STAGE2_CHESTS) / sizeof(STAGE2_CHESTS[0]);

// Stage 3
static const ChestConfig STAGE3_CHESTS[] = {
    {'A', "weapon", "ë§ˆë ¥ì˜ ê²€"},
    {'B', "armor",  "ë§ˆë‚˜ ê°‘ì˜·"},
    {'C', "item",   "ìµœëŒ€ HP +5"},
    {'D', "item",   "ê³µê²©ë ¥ +2"},
    {'E', "item",   "ë°©ì–´ë ¥ +2"},
};
static const int STAGE3_CHEST_COUNT = sizeof(STAGE3_CHESTS) / sizeof(STAGE3_CHESTS[0]);


// ========================
// ë§µ ë°ì´í„° ì •ì˜ (ìƒë‹¨ì— ëª¨ì•„ë‘ê¸°)
// ========================

static const char* MAP_STAGE_1[] = {
"########################################################################################################################",
"########################################################################################################################",
"############....................##############..........###########....................###############################",
"############....................##############..........###########....................###############################",
"############....................##############..........###########....................###############################",
"############....................##############..........###########....................###############################",
"############....................##############..........###########....................###############################",
"############....................##############..........###########....................###############################",
"############....................##############..........###########....................###############################",
"############....................##############..........###########....................###############################",
"############....................##############..........###########....................###############################",
"############....................##############..........###########....................###############################",
"############....................##############..........###########....................###############################",
"############....................##############..........###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.....@.......###########.......................###########............A.......###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.....a.......###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########......b.............###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########...............................................###########....................###############....###########",
"########...............................................###########....................###############....###########",
"########...............................................###########....................###############....###########",
"########...............................................###########....................###############....###########",
"########...............................................###########....................###############....###########",
"########...............................................###########....................###############....###########",
"########...............................................###########....................###############....###########",
"########...............................................###########....................###############....###########",
"########...............................................###########....................###############....###########",
"########...............................................###########....................###############....###########",
"########...............................................###########....................###############....###########",
"###############.................#######################################################################....########",
"###############.................#######################################################################....########",
"###############.................#######################################################################....########",
"###############.................#######################################################################....########",
"###############.................########################C##############################################....########",
"###############.................########################.##############################################....########",
"###############.................########################.##############################################....########",
"###############.................########################.##############################################....########",
"###############.................########################.##############################################....########",
"###############.................########################.##############################################....########",
"###############....c............########################.##############################################....########",
"###############.................########################.##############################################....########",
"###############.................########################.##############################################....########",
"###############.................########################.##############################################....########",
"########################################################################################################################",
"########################################################################################################################"
};


static const char* MAP_STAGE_2[] = {
    "########################################",
    "#====================================..#",
    "#====================================..#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "########################################"
};

static const char* MAP_STAGE_3[] = {
    "####################",
    "#..................#",
    "#....####..........#",
    "#....#..#..........#",
    "#....####..........#",
    "#..................#",
    "#..................#",
    "#..................#",
    "#..................#",
    "####################"
};

static const char* MAP_DEFAULT[] = {
    "####################",
    "#..................#",
    "#..................#",
    "#..................#",
    "#..................#",
    "#..................#",
    "#..................#",
    "#..................#",
    "#..................#",
    "####################"
};

// ========================
// ë¡œì§ í•¨ìˆ˜ë“¤
// ========================

// â˜… ê³µí†µ ë¡œë“œ í•¨ìˆ˜
static void load_map_from_data(Map* m, const char** mapData, int height) {
    m->height = height;
    m->width = strlen(mapData[0]);

    for (int y = 0; y < m->height && y < MAX_MAP_H; y++) {
        for (int x = 0; x < m->width && x < MAX_MAP_W; x++) {
            m->tiles[y][x] = mapData[y][x];
        }
    }
}

// â˜… ìŠ¤í…Œì´ì§€ ë²ˆí˜¸ë¡œ ë§µ ë¡œë“œ
void load_map(Map* m, int stageNumber) {
    switch (stageNumber) {
    case 1:
        load_map_from_data(m, MAP_STAGE_1, sizeof(MAP_STAGE_1) / sizeof(MAP_STAGE_1[0]));
        break;
    case 2:
        load_map_from_data(m, MAP_STAGE_2, sizeof(MAP_STAGE_2) / sizeof(MAP_STAGE_2[0]));
        break;
    case 3:
        load_map_from_data(m, MAP_STAGE_3, sizeof(MAP_STAGE_3) / sizeof(MAP_STAGE_3[0]));
        break;
    default:
        load_map_from_data(m, MAP_DEFAULT, sizeof(MAP_DEFAULT) / sizeof(MAP_DEFAULT[0]));
        break;
    }
}

const ChestConfig* get_chest_config(int stage, int* outCount) {
    switch (stage) {
    case 1:
        *outCount = STAGE1_CHEST_COUNT;
        return STAGE1_CHESTS;

    case 2:
        *outCount = STAGE2_CHEST_COUNT;
        return STAGE2_CHESTS;

    case 3:
        *outCount = STAGE3_CHEST_COUNT;
        return STAGE3_CHESTS;
    }

    *outCount = 0;
    return NULL;
}


------------------------------------------------------------
[FILE PATH] C:\projects\MetroHero\MetroHero\src\world\map_data.h
[FILE NAME] map_data.h
------------------------------------------------------------

#ifndef MAP_DATA_H
#define MAP_DATA_H

#include "map.h"

typedef struct {
	char tile;              // 'A', 'B', 'C' ...
	const char* itemType;   // "weapon", "armor", "item"
	const char* itemName;   // "ì´ˆë³´ì ê²€"
} ChestConfig;

const ChestConfig* get_chest_config(int stage , int* outCount);

// â˜… ë‹¨ì¼ í•¨ìˆ˜ë¡œ ë³€ê²½
void load_map(Map* m , int stageNumber);

#endif

=== Source Collection End ===
