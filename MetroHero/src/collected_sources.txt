=== Source Collection Start ===

------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\main.c
[FILE NAME] main.c
------------------------------------------------------------

#include <windows.h>
#include "core/game.h"
#include "debug/debug.h"  // â˜… ì¶”ê°€

int main(void) {

    // debug_console_info();

    game_run();
    return 0;
}


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\cinematic\cinematic.c
[FILE NAME] cinematic.c
------------------------------------------------------------

#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <conio.h>
#include "cinematic.h"
#include "../core/ui/ui.h"
#include "../world/glyph.h"
// #include "../data/story.h" // Removed
#include "../world/map_data.h" // For get_stage_data

// ============================================
// Global Cinematics (Moved from story.h)
// ============================================

// --- Intro ---
static const CinematicLine INTRO_LINES[] = {
	{ "", STYLE_NORMAL, 500 },
	{ "ê°‘ìê¸° ë‹¹ì‹ ì€ ëˆˆì„ ë–´ë‹¤...", STYLE_TYPEWRITER, 800 },
	{ "", STYLE_NORMAL, 300 },
	{ "ì´ê³³ì€...", STYLE_TYPEWRITER, 800 },
	{ "", STYLE_NORMAL, 300 },
	{ "ì„±ê· ê´€ëŒ€ì—­....?", STYLE_TYPEWRITER, 1000 },
	{ "", STYLE_NORMAL, 300 },
	{ "ë‹¹ì‹ ì€ ëª¸ì„ ì¼ìœ¼ì¼œ ì£¼ìœ„ë¥¼ ë‘˜ëŸ¬ë³¸ë‹¤...", STYLE_TYPEWRITER, 0 },
};

static const Cinematic STORY_INTRO = {
    "â˜…  M E T R O   H E R O  â˜…",
    INTRO_LINES,
    sizeof(INTRO_LINES) / sizeof(INTRO_LINES[0]),
    30,     // íƒ€ì´í•‘ ì†ë„
    1,      // ìŠ¤í‚µ íŒíŠ¸ í‘œì‹œ
    COLOR_BRIGHT_CYAN,
    COLOR_WHITE
};

// --- Good Ending ---
static const CinematicLine ENDING_GOOD_LINES[] = {
    { "", STYLE_NORMAL, 500 },
    { "ë‹¹ì‹ ì€ í•´ëƒˆë‹¤.", STYLE_TYPEWRITER, 1000 },
    { "", STYLE_NORMAL, 500 },
    { "ì§€í•˜ì² ì˜ ì–´ë‘ ì€ ë¬¼ëŸ¬ê°€ê³ ,", STYLE_TYPEWRITER, 800 },
    { "ì‹œë¯¼ë“¤ì€ ë‹¤ì‹œ ì•ˆì „í•˜ê²Œ ì´ë™í•  ìˆ˜ ìˆê²Œ ë˜ì—ˆë‹¤.", STYLE_TYPEWRITER, 1000 },
    { "", STYLE_NORMAL, 500 },
    { "í•˜ì§€ë§Œ ì˜ì›…ì˜ ì´ì•¼ê¸°ëŠ”", STYLE_TYPEWRITER, 600 },
    { "ëˆ„êµ¬ì—ê²Œë„ ì•Œë ¤ì§€ì§€ ì•Šì•˜ë‹¤...", STYLE_TYPEWRITER, 1000 },
    { "", STYLE_NORMAL, 800 },
    { "ê·¸ê²ƒì´ ì§„ì •í•œ ì˜ì›…ì˜ ê¸¸.", STYLE_TYPEWRITER, 0 },
};

static const Cinematic STORY_ENDING_GOOD = {
    "â˜…  T H E   E N D  â˜…",
    ENDING_GOOD_LINES,
    sizeof(ENDING_GOOD_LINES) / sizeof(ENDING_GOOD_LINES[0]),
    35,
    1,
    COLOR_BRIGHT_YELLOW,
    COLOR_WHITE
};

// --- Bad Ending ---
static const CinematicLine ENDING_BAD_LINES[] = {
    { "", STYLE_NORMAL, 500 },
    { "ì–´ë‘ ì´ ë‹¹ì‹ ì„ ì‚¼ì¼°ë‹¤...", STYLE_TYPEWRITER, 1000 },
    { "", STYLE_NORMAL, 500 },
    { "ì§€í•˜ì² ì˜ ìˆ˜í˜¸ìëŠ” ì“°ëŸ¬ì¡Œê³ ,", STYLE_TYPEWRITER, 800 },
    { "ë„ì‹œëŠ” ì˜ì›í•œ ì–´ë‘  ì†ì— ë‚¨ê²¨ì¡Œë‹¤.", STYLE_TYPEWRITER, 1000 },
    { "", STYLE_NORMAL, 800 },
    { "í•˜ì§€ë§Œ í¬ë§ì€ ì‚¬ë¼ì§€ì§€ ì•ŠëŠ”ë‹¤.", STYLE_TYPEWRITER, 600 },
    { "ì–¸ì  ê°€ ìƒˆë¡œìš´ ì˜ì›…ì´ ë‚˜íƒ€ë‚  ê²ƒì´ë‹¤...", STYLE_TYPEWRITER, 0 },
};

static const Cinematic STORY_ENDING_BAD = {
    "G A M E   O V E R",
    ENDING_BAD_LINES,
    sizeof(ENDING_BAD_LINES) / sizeof(ENDING_BAD_LINES[0]),
    40,
    1,
    COLOR_BRIGHT_RED,
    COLOR_GRAY
};


// ============================================
// ë‚´ë¶€ ìƒìˆ˜ (Layout.h ê¸°ë°˜ ë™ì  ì¡°ì •)
// ============================================

#define CINE_X      SCREEN_PADDING_LEFT
#define CINE_Y      SCREEN_PADDING_TOP

// í…Œë‘ë¦¬ê°€ ê·¸ë ¤ì§ˆ ì‹¤ì œ í¬ê¸° (í™”ë©´ ì „ì²´ ë®ì§€ ì•Šê³  íŒ¨ë”© ê°ì•ˆ)
// ìš°ì¸¡/í•˜ë‹¨ ì—¬ë°±ë„ ì¢Œì¸¡/ìƒë‹¨ê³¼ ë¹„ìŠ·í•˜ê²Œ ì¤Œ
#define CINE_WIDTH  (SCREEN_W - CINE_X - 4) 
#define CINE_HEIGHT (SCREEN_H - CINE_Y - 2)

// í…ìŠ¤íŠ¸ í‘œì‹œ ì˜ì—­ (í…Œë‘ë¦¬ ë‚´ë¶€)
#define CONTENT_X       (CINE_X + 4)
#define CONTENT_Y       (CINE_Y + 3)
#define CONTENT_WIDTH   (CINE_WIDTH - 8)
#define CONTENT_HEIGHT  (CINE_HEIGHT - 6)

// í•˜ë‹¨ ì•ˆë‚´ ë©”ì‹œì§€ ìœ„ì¹˜
#define CONTENT_MAX_Y   (CONTENT_Y + CONTENT_HEIGHT - 1)

// ============================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// ============================================

// í™”ë©´ ì „ì²´ ì§€ìš°ê¸°
static void cinematic_clear(void) {
    ui_clear_buffer();
}

// ì§€ì • ìœ„ì¹˜ë¡œ ì»¤ì„œ ì´ë™ (ë”ë¯¸ - ì‹¤ì œë¡œëŠ” drawí•¨ìˆ˜ê°€ ì¢Œí‘œ ë°›ìŒ)
static void cinematic_goto(int x, int y) {
    // console_goto(x, y); // Not needed for buffer
}

// ms ë‹¨ìœ„ ëŒ€ê¸°
static void cinematic_delay(int ms) {
    Sleep(ms);
}

// í‚¤ ì…ë ¥ ì²´í¬ (ë…¼ë¸”ë¡œí‚¹)
static int cinematic_key_pressed(void) {
    return _kbhit();
}

// í‚¤ ì…ë ¥ ì½ê¸°
static int cinematic_get_key(void) {
    return _getch();
}

// ============================================
// í…Œë‘ë¦¬ ê·¸ë¦¬ê¸°
// ============================================

void cinematic_draw_frame(const char* borderColor) {
    const char* color = borderColor ? borderColor : COLOR_WHITE;

    cinematic_clear();

    int right = CINE_X + CINE_WIDTH - 1;
    int bottom = CINE_Y + CINE_HEIGHT - 1;

    // ìƒë‹¨ í…Œë‘ë¦¬
    ui_draw_str_at(CINE_X, CINE_Y, "â•”", color);
    for (int i = CINE_X + 1; i < right; i++) ui_draw_str_at(i, CINE_Y, "â•", color);
    ui_draw_str_at(right, CINE_Y, "â•—", color);

    // ì¢Œìš° í…Œë‘ë¦¬
    for (int y = CINE_Y + 1; y < bottom; y++) {
        ui_draw_str_at(CINE_X, y, "â•‘", color);
        ui_draw_str_at(right, y, "â•‘", color);
    }

    // í•˜ë‹¨ í…Œë‘ë¦¬
    ui_draw_str_at(CINE_X, bottom, "â•š", color);
    for (int i = CINE_X + 1; i < right; i++) ui_draw_str_at(i, bottom, "â•", color);
    ui_draw_str_at(right, bottom, "â•", color);
    
    ui_present(); // ê¸°ë³¸ í”„ë ˆì„ ê·¸ë¦¼
}

// ============================================
// ì¤‘ì•™ ì •ë ¬ í…ìŠ¤íŠ¸ ì¶œë ¥
// ============================================

void cinematic_print_centered(int y, const char* text, const char* color) {
    int textWidth = display_width(text);
    int x = CINE_X + (CINE_WIDTH - textWidth) / 2; // Add global offset
    if (x < CONTENT_X) x = CONTENT_X;

    ui_draw_str_at(x, y, text, color);
    // ui_present(); // ì œê±°: í˜¸ì¶œìê°€ ì œì–´
}

// ============================================
// íƒ€ì´í•‘ íš¨ê³¼ í…ìŠ¤íŠ¸ ì¶œë ¥
// ============================================

void cinematic_print_typewriter(int x, int y, const char* text, const char* color, int charDelay) {
    const unsigned char* s = (const unsigned char*)text;
    int curX = x;

    while (*s) {
        // ESC ìŠ¤í‚µ ì²´í¬
        if (cinematic_key_pressed()) {
            int key = cinematic_get_key();
            if (key == 27) {  // ESC
                // ë‚¨ì€ í…ìŠ¤íŠ¸ í•œë²ˆì— ì¶œë ¥
                ui_draw_str_at(curX, y, (const char*)s, color);
                ui_present();
                return;
            }
        }

        // ANSI ì´ìŠ¤ì¼€ì´í”„ ì‹œí€€ìŠ¤ ì²˜ë¦¬
        if (*s == '\033' || *s == 0x1B) {
            const char* start = (const char*)s;
            s++;
            if (*s == '[') {
                while (*s && *s != 'm') s++;
                if (*s == 'm') s++;
            }
             
             int len = (int)((const unsigned char*)s - (const unsigned char*)start);
             char buf[32];
             strncpy(buf, start, len);
             buf[len] = 0;
             ui_draw_str_at(curX, y, buf, color);
             // Don't advance curX for ANSI
             continue;
        }

        // UTF-8 ë¬¸ì ì²˜ë¦¬ & Width calc (Use Centered Helper)
        int charLen = 1;
        int charWidth = 1;
        
        ui_get_glyph_info((const char*)s, &charLen, &charWidth);
        
        char buf[8] = {0};
        strncpy(buf, (const char*)s, charLen);
        
        // Draw
        ui_draw_str_at(curX, y, buf, color);
        ui_present();
        
        s += charLen;
        curX += charWidth;

        cinematic_delay(charDelay);
    }
}

// ============================================
// ìŠ¤í¬ë¡¤ í…ìŠ¤íŠ¸ (ìŠ¤íƒ€ì›Œì¦ˆ ìŠ¤íƒ€ì¼)
// ============================================

void cinematic_scroll_text(const char** lines, int lineCount, int speed) {
    // ìŠ¤í¬ë¡¤ ì˜ì—­: í™”ë©´ ì¤‘ì•™ ë¶€ë¶„
    int scrollTop = CINE_Y + 6;
    int scrollBottom = CINE_Y + CINE_HEIGHT - 6;
    int scrollHeight = scrollBottom - scrollTop;

    // ëª¨ë“  ë¼ì¸ì„ ì•„ë˜ì—ì„œ ìœ„ë¡œ ìŠ¤í¬ë¡¤
    for (int offset = scrollHeight; offset > -lineCount; offset--) {
        // ESC ìŠ¤í‚µ ì²´í¬
        if (cinematic_key_pressed()) {
            int key = cinematic_get_key();
            if (key == 27) return;
        }

        // ìŠ¤í¬ë¡¤ ì˜ì—­ ì§€ìš°ê¸°
        for (int y = scrollTop; y < scrollBottom; y++) {
             ui_draw_str_at(CONTENT_X, y, "                                                                                                                ", NULL); 
        }

        // í˜„ì¬ ë³´ì´ëŠ” ë¼ì¸ë“¤ ì¶œë ¥
        for (int i = 0; i < lineCount; i++) {
            int screenY = scrollTop + offset + i;

            if (screenY >= scrollTop && screenY < scrollBottom) {
                
                int distFromCenter = abs(screenY - (scrollTop + scrollHeight / 2));
                const char* fadeColor;

                if (distFromCenter < 3) {
                    fadeColor = COLOR_BRIGHT_WHITE;
                }
                else if (distFromCenter < 5) {
                    fadeColor = COLOR_WHITE;
                }
                else if (distFromCenter < 7) {
                    fadeColor = COLOR_GRAY;
                }
                else {
                    fadeColor = COLOR_DARK_GRAY;
                }

                cinematic_print_centered(screenY, lines[i], fadeColor);
            }
        }

        ui_present();
        cinematic_delay(speed);
    }
}

// ============================================
// í‚¤ ì…ë ¥ ëŒ€ê¸° (ê¹œë¹¡ì„ íš¨ê³¼ í¬í•¨)
// ============================================

int cinematic_wait_key(int showHint) {
    // showHintê°€ ì°¸ì´ë©´ í•˜ë‹¨ ì•ˆë‚´ ë©”ì‹œì§€ë¥¼ ê¹œë¹¡ì„
    int blinkState = 0;
    int elapsed = 0;
    const int BLINK_INTERVAL = 500; // 0.5ì´ˆ

    while (1) {
        if (cinematic_key_pressed()) {
            int key = cinematic_get_key();
            
            // í‚¤ ì…ë ¥ ì‹œ ì•ˆë‚´ ë©”ì‹œì§€ë¥¼ ì›ë˜ ìƒ‰(íšŒìƒ‰)ìœ¼ë¡œ ë³µêµ¬
            if (showHint) {
                cinematic_print_centered(CINE_HEIGHT - 3,
                    "[SPACE] ê³„ì†    [ESC] ìŠ¤í‚µ", COLOR_GRAY);
            }

            if (key == ' ' || key == 13) {  // SPACE ë˜ëŠ” ENTER
                return 0;  // ê³„ì†
            }
            else if (key == 27) {  // ESC
                return 1;  // ìŠ¤í‚µ
            }
        }

        // ê¹œë¹¡ì„ ì²˜ë¦¬
        if (showHint) {
            elapsed += 50;
            if (elapsed >= BLINK_INTERVAL) {
                elapsed = 0;
                blinkState = !blinkState;
                
                const char* blinkColor = blinkState ? COLOR_BRIGHT_WHITE : COLOR_GRAY;
                cinematic_print_centered(CINE_HEIGHT - 3,
                    "[SPACE] ê³„ì†    [ESC] ìŠ¤í‚µ", blinkColor);
            }
        }

        ui_present();
        cinematic_delay(50);
    }
}

// ============================================
// í˜ì´ë“œ íš¨ê³¼
// ============================================

void cinematic_fade_in(int duration) {
    // ë‹¨ê³„ë³„ í˜ì´ë“œ ì¸ (3ë‹¨ê³„)
    int stepDelay = duration / 3;
    cinematic_delay(stepDelay);
    cinematic_delay(stepDelay);
    cinematic_delay(stepDelay);
}

void cinematic_fade_out(int duration) {
    int stepDelay = duration / 3;
    cinematic_delay(stepDelay);
    cinematic_delay(stepDelay);
    cinematic_delay(stepDelay);
}

// ============================================
// ë©”ì¸ ì‹œë„¤ë§ˆí‹± ì¬ìƒ í•¨ìˆ˜
// ============================================

void cinematic_play(const Cinematic* cine) {
    if (!cine || !cine->lines || cine->lineCount <= 0) return;

    // í™”ë©´ ì¤€ë¹„
    cinematic_draw_frame(cine->borderColor);

    // ì œëª© í‘œì‹œ
    if (cine->title) {
        cinematic_print_centered(CINE_Y + 2, cine->title, COLOR_BRIGHT_YELLOW);

        // ì œëª© ì•„ë˜ êµ¬ë¶„ì„ 
        char sep[1024] = "";
        for (int i = 0; i < CONTENT_WIDTH; i++) strcat(sep, "â”€");
        
        ui_draw_str_at(CONTENT_X, CINE_Y + 3, sep, COLOR_YELLOW);
        ui_present();
    }

    // â˜… í•˜ë‹¨ ì•ˆë‚´ ë©”ì‹œì§€ í‘œì‹œ (ì²˜ìŒë¶€í„° í•­ìƒ í‘œì‹œ)
    if (cine->showSkipHint) {
        cinematic_print_centered(CINE_HEIGHT - 3,
            "[SPACE] ê³„ì†    [ESC] ìŠ¤í‚µ", COLOR_GRAY);
    }

    // ê° ë¼ì¸ ì²˜ë¦¬
    int currentY = cine->title ? (CONTENT_Y + 2) : CONTENT_Y;
    int skipped = 0;

    for (int i = 0; i < cine->lineCount && !skipped; i++) {
        const CinematicLine* line = &cine->lines[i];

        // â˜… ESC í‚¤ë¡œ ì–¸ì œë“ ì§€ ìŠ¤í‚µ ê°€ëŠ¥
        if (cinematic_key_pressed()) {
            int key = cinematic_get_key();
            if (key == 27) {  // ESC
                skipped = 1;
                break;
            }
        }

        // â˜… í•˜ë‹¨ ì•ˆë‚´ ë©”ì‹œì§€ ì˜ì—­ ë³´í˜¸: Yê°€ CONTENT_MAX_Yë¥¼ ë„˜ìœ¼ë©´ ì¶œë ¥ ì¤‘ë‹¨
        if (currentY > CONTENT_MAX_Y) {
            break;
        }

        switch (line->style) {
            case STYLE_TITLE:
                cinematic_print_centered(currentY, line->text, COLOR_BRIGHT_YELLOW);
                ui_present();
                currentY += 2;
                break;

            case STYLE_SUBTITLE:
                cinematic_print_centered(currentY, line->text, COLOR_YELLOW);
                ui_present();
                currentY += 2;
                break;

            case STYLE_TYPEWRITER: {
                int textWidth = display_width(line->text);
                int x = CINE_X + (CINE_WIDTH - textWidth) / 2;
                if (x < CONTENT_X) x = CONTENT_X;

                const char* color = cine->textColor ? cine->textColor : COLOR_WHITE;
                
                cinematic_print_typewriter(x, currentY, line->text, color,
                    cine->scrollSpeed > 0 ? cine->scrollSpeed : 30);
                
                currentY += 2;
                break;
            }

            case STYLE_SCROLL_UP:
                cinematic_scroll_text((const char**)line->text, 10, cine->scrollSpeed); 
                break;

            case STYLE_FADE_IN:
                cinematic_fade_in(500);
                cinematic_print_centered(currentY, line->text,
                    cine->textColor ? cine->textColor : COLOR_WHITE);
                ui_present();
                currentY += 2;
                break;

            case STYLE_NORMAL:
            default:
                cinematic_print_centered(currentY, line->text,
                    cine->textColor ? cine->textColor : COLOR_WHITE);
                ui_present();
                currentY += 1;
                break;
        }

        // ë¼ì¸ í›„ ëŒ€ê¸°
        if (line->delayAfter > 0) {
            // â˜… ë”œë ˆì´ ì¤‘ì—ë„ ESCë¡œ ìŠ¤í‚µ ê°€ëŠ¥í•˜ë„ë¡ ì§§ì€ ë‹¨ìœ„ë¡œ ë‚˜ëˆ ì„œ ì²´í¬
            int remainingDelay = line->delayAfter;
            const int checkInterval = 50;  // 50msë§ˆë‹¤ ì²´í¬

            while (remainingDelay > 0 && !skipped) {
                int waitTime = (remainingDelay < checkInterval) ? remainingDelay : checkInterval;
                cinematic_delay(waitTime);
                remainingDelay -= waitTime;

                if (cinematic_key_pressed()) {
                    int key = cinematic_get_key();
                    if (key == 27) {  // ESC
                        skipped = 1;
                        break;
                    }
                }
            }
        }
        else if (line->delayAfter == 0 && line->style != STYLE_NORMAL) {
            // í‚¤ ì…ë ¥ ëŒ€ê¸° (íŒíŠ¸ ê¹œë¹¡ì„ ì ìš©)
            skipped = cinematic_wait_key(cine->showSkipHint);
        }
    }

    // ìŠ¤í‚µí•˜ì§€ ì•Šì•˜ìœ¼ë©´ ìµœì¢… í‚¤ ëŒ€ê¸° (íŒíŠ¸ ê¹œë¹¡ì„ ì ìš©)
    if (!skipped && cine->showSkipHint) {
        cinematic_wait_key(cine->showSkipHint);
    }

    // í˜ì´ë“œ ì•„ì›ƒ
    cinematic_fade_out(300);
}

// ============================================
// ë¯¸ë¦¬ ì •ì˜ëœ ì‹œë„¤ë§ˆí‹± (Using StageData or Globals)
// ============================================

void cinematic_play_intro(void) {
    cinematic_play(&STORY_INTRO);
}

void cinematic_play_stage_start(int stageNum) {
    const StageData* data = get_stage_data(stageNum);
    if (data && data->intro) {
        cinematic_play(data->intro);
    }
}

void cinematic_play_stage_clear(int stageNum) {
    const StageData* data = get_stage_data(stageNum);
    if (data && data->outro) {
        cinematic_play(data->outro);
    }
}

void cinematic_play_ending(int endingType) {
    if (endingType == 0) {
        cinematic_play(&STORY_ENDING_GOOD);
    }
    else {
        cinematic_play(&STORY_ENDING_BAD);
    }
}


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\cinematic\cinematic.h
[FILE NAME] cinematic.h
------------------------------------------------------------

#ifndef CINEMATIC_H
#define CINEMATIC_H

// ============================================
// ì‹œë„¤ë§ˆí‹± ì‹œìŠ¤í…œ - ìŠ¤íƒ€ì›Œì¦ˆ ìŠ¤íƒ€ì¼ í’€ìŠ¤í¬ë¦° ëŒ€í™”ì°½
// ============================================

// ì‹œë„¤ë§ˆí‹± íƒ€ì…
typedef enum {
    CINEMATIC_INTRO,        // ê²Œì„ ì‹œì‘ ì¸íŠ¸ë¡œ
    CINEMATIC_STAGE_CLEAR,  // ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´
    CINEMATIC_STAGE_START,  // ìŠ¤í…Œì´ì§€ ì‹œì‘
    CINEMATIC_ENDING_GOOD,  // ì¢‹ì€ ì—”ë”©
    CINEMATIC_ENDING_BAD,   // ë‚˜ìœ ì—”ë”© (ì‚¬ë§)
    CINEMATIC_CUSTOM        // ì»¤ìŠ¤í…€ ì´ë²¤íŠ¸
} CinematicType;

// í…ìŠ¤íŠ¸ í‘œì‹œ ìŠ¤íƒ€ì¼
typedef enum {
    STYLE_NORMAL,           // ì¼ë°˜ í…ìŠ¤íŠ¸
    STYLE_TITLE,            // ì œëª© (í¬ê²Œ, ì¤‘ì•™ ì •ë ¬)
    STYLE_SUBTITLE,         // ë¶€ì œëª©
    STYLE_SCROLL_UP,        // ì•„ë˜â†’ìœ„ ìŠ¤í¬ë¡¤ (ìŠ¤íƒ€ì›Œì¦ˆ)
    STYLE_TYPEWRITER,       // íƒ€ì´í•‘ íš¨ê³¼
    STYLE_FADE_IN           // í˜ì´ë“œ ì¸
} TextStyle;

// ì‹œë„¤ë§ˆí‹± ë¼ì¸ êµ¬ì¡°ì²´
typedef struct {
    const char* text;       // í…ìŠ¤íŠ¸ ë‚´ìš©
    TextStyle style;        // í‘œì‹œ ìŠ¤íƒ€ì¼
    int delayAfter;         // ì´ ë¼ì¸ í›„ ëŒ€ê¸°ì‹œê°„ (ms), 0ì´ë©´ í‚¤ ì…ë ¥ ëŒ€ê¸°
} CinematicLine;

// ì‹œë„¤ë§ˆí‹± êµ¬ì¡°ì²´
typedef struct {
    const char* title;              // ìƒë‹¨ ì œëª© (NULLì´ë©´ í‘œì‹œ ì•ˆí•¨)
    const CinematicLine* lines;     // í…ìŠ¤íŠ¸ ë¼ì¸ ë°°ì—´
    int lineCount;                  // ë¼ì¸ ìˆ˜
    int scrollSpeed;                // ìŠ¤í¬ë¡¤ ì†ë„ (ms), ê¸°ë³¸ê°’ 50
    int showSkipHint;               // "[ESC] ìŠ¤í‚µ" í‘œì‹œ ì—¬ë¶€
    const char* borderColor;        // í…Œë‘ë¦¬ ìƒ‰ìƒ (ANSI ì½”ë“œ)
    const char* textColor;          // ê¸°ë³¸ í…ìŠ¤íŠ¸ ìƒ‰ìƒ
} Cinematic;

// ============================================
// ë©”ì¸ í•¨ìˆ˜
// ============================================

// ì‹œë„¤ë§ˆí‹± ì¬ìƒ (ë²”ìš©)
void cinematic_play(const Cinematic* cine);

// ë¯¸ë¦¬ ì •ì˜ëœ ì‹œë„¤ë§ˆí‹± ì¬ìƒ
void cinematic_play_intro(void);
void cinematic_play_stage_start(int stageNum);
void cinematic_play_stage_clear(int stageNum);
void cinematic_play_ending(int endingType);

// ============================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// ============================================

// í™”ë©´ ì „ì²´ ì§€ìš°ê³  í…Œë‘ë¦¬ ê·¸ë¦¬ê¸°
void cinematic_draw_frame(const char* borderColor);

// ì¤‘ì•™ ì •ë ¬ í…ìŠ¤íŠ¸ ì¶œë ¥
void cinematic_print_centered(int y, const char* text, const char* color);

// íƒ€ì´í•‘ íš¨ê³¼ë¡œ í…ìŠ¤íŠ¸ ì¶œë ¥
void cinematic_print_typewriter(int x, int y, const char* text, const char* color, int charDelay);

// ìŠ¤í¬ë¡¤ í…ìŠ¤íŠ¸ (ìŠ¤íƒ€ì›Œì¦ˆ ìŠ¤íƒ€ì¼)
void cinematic_scroll_text(const char** lines, int lineCount, int speed);

// í‚¤ ì…ë ¥ ëŒ€ê¸° (SPACE: ê³„ì†, ESC: ìŠ¤í‚µ)
// ë°˜í™˜ê°’: 0 = ê³„ì†, 1 = ìŠ¤í‚µ
int cinematic_wait_key(int showHint);

// í˜ì´ë“œ íš¨ê³¼ (ë°ê¸° ì¡°ì ˆ)
void cinematic_fade_in(int duration);
void cinematic_fade_out(int duration);

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\game.c
[FILE NAME] game.c
------------------------------------------------------------

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include "game.h"
#include "system/game_internal.h"
#include "ui/ui.h"
#include "../cinematic/cinematic.h"
#include "../world/map.h"
#include "../entity/player.h"

// ê²Œì„ ì‹¤í–‰ (ì§„ì…ì )
void game_run(void) {
    // 1. ìƒíƒœ ì´ˆê¸°í™”
    GameState state = { 0 };  // ëª¨ë“  í•„ë“œ 0/NULL ì´ˆê¸°í™”

    ui_init();

    // ì¸íŠ¸ë¡œ ì‹œë„¤ë§ˆí‹±
    cinematic_play_intro();

    map_init(&state.map, 1);
    player_init(&state.player);

    // ìŠ¤í…Œì´ì§€ 1 ì‹œì‘
    cinematic_play_stage_start(1);

    // í”Œë ˆì´ì–´ ë°°ì¹˜
    state.player.x = state.map.spawnX;
    state.player.y = state.map.spawnY;
    
    // ì´ˆê¸° ë·°í¬íŠ¸ ìƒíƒœ ì„¤ì • (ê°•ì œ ë Œë”ë§ì„ ìœ„í•´ ë‹¤ë¥´ê²Œ ì„¤ì •)
    state.prevX = -1;
    state.prevY = -1;
    state.isRunning = 1;
    state.inDialogue = 0;
    state.currentNPC = NULL;

    // ì´ˆê¸° í™”ë©´ ê·¸ë¦¬ê¸° (ë Œë”ë§ ëª¨ë“ˆì—ì„œ ì¼ë¶€ ìˆ˜í–‰í•˜ì§€ë§Œ, ì „ì²´ í´ë¦¬ì–´ëŠ” ì—¬ê¸°ì„œ í•˜ëŠ”ê²Œ ê¹”ë”í•  ìˆ˜ ìˆìŒ)
    ui_clear_buffer();
    
    // ë·°í¬íŠ¸, UI ì´ˆê¸°í™” ê·¸ë¦¬ê¸°
    game_render(&state);

    // ì…ë ¥ ì•ˆë‚´
    ui_draw_str_at(0, SCREEN_H - 1, "[í™”ì‚´í‘œ/WASD] ì´ë™ | [0] ìƒí˜¸ì‘ìš© | [Q] ì¢…ë£Œ", NULL);
    ui_present();

    // 2. ë©”ì¸ ë£¨í”„ ì‹¤í–‰
    game_loop(&state);
}


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\game.h
[FILE NAME] game.h
------------------------------------------------------------

#ifndef GAME_H
#define GAME_H

void game_run(void);

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\logic\combat.c
[FILE NAME] combat.c
------------------------------------------------------------

// core/combat.c
#include <stdio.h>
#include <windows.h>  // Sleep ì‚¬ìš©

#include "combat.h"
#include "../ui/ui.h"
#include "../../world/map.h"
#include "../../world/glyph.h"  // â˜… ì¶”ê°€


// â˜… ì¸ì ‘ ì  ì²´í¬ ë° ë©”ì‹œì§€ (ì²´ë ¥ + ìˆœí™˜ ëŒ€ì‚¬ í¬í•¨)
void combat_check_nearby_enemy(Map* m, Player* p) {
    Enemy* e = map_get_adjacent_enemy(m, p->x, p->y);
    if (e == NULL) return;

    const char* direction = map_get_enemy_direction(m, p->x, p->y, e);

    // â˜… í˜„ì¬ ëŒ€ì‚¬ë¥¼ êº¼ë‚¸ë‹¤
    const char* line = e->dialogues[e->dialogueIndex];

    // â˜… ë‹¤ìŒ ì ‘ê·¼ ì‹œ ë‹¤ìŒ ëŒ€ì‚¬ ì¶œë ¥ë˜ë„ë¡ index ì¦ê°€ (ìˆœí™˜)
    e->dialogueIndex = (e->dialogueIndex + 1) % e->dialogueCount;

    char logMsg[512];
    snprintf(logMsg, sizeof(logMsg),
        "%s%sì— %sì´(ê°€) ì„œìˆë‹¤! (HP: %d/%d) %sã€Œ%sã€%s",
        COMBAT_DETECT,
        direction,
        e->name,
        e->hp, e->maxHp,

        e->dialogueColor,   // â˜… ëŒ€ì‚¬ ìƒ‰ê¹”
        line,                // â˜… ëŒ€ì‚¬ ë‚´ìš©
        COLOR_RESET          // â˜… ë¦¬ì…‹ì„ ë§¨ ë’¤ì— ê°•ì œ ë°°ì¹˜
    );

    ui_add_log(logMsg);
}

// â˜… ì „íˆ¬ ì‹œìŠ¤í…œ
void combat_attack_enemy(Player* p, Enemy* e, Map* m) {
    char logMsg[128];

    // â˜… ì „íˆ¬ ì´í™íŠ¸ í‘œì‹œ (ìƒíƒœì°½ ë‚´ë¶€ ì˜¤ë¥¸ìª½)
    ui_show_combat_effect();

    // â˜…â˜…â˜… í”Œë ˆì´ì–´ ê³µê²© - ëœë¤ ë°ë¯¸ì§€ â˜…â˜…â˜…
    int playerAttack = p->attackMin + rand() % (p->attackMax - p->attackMin + 1);
    int playerDamage = playerAttack - e->defense;
    if (playerDamage < 1) playerDamage = 1;

    e->hp -= playerDamage;

    // â˜… ë°ì€ ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ê°•ì¡°
    snprintf(logMsg, sizeof(logMsg),
        COMBAT_ATTACK "âš” %së¥¼ ê³µê²©! " COMBAT_DAMAGE "%d ë°ë¯¸ì§€!" COLOR_RESET " (HP: %d/%d)",
        e->name, playerDamage, e->hp > 0 ? e->hp : 0, e->maxHp);
    ui_add_log(logMsg);

    // â˜… ì ê¹ ëŒ€ê¸° (íƒ€ê²©ê°)
    //Sleep(100);

    // ì  ì‚¬ë§ ì²´í¬
    if (e->hp <= 0) {
        e->isAlive = 0;
        // â˜… ë³´ë¼ìƒ‰ìœ¼ë¡œ ê°•ì¡°
        snprintf(logMsg, sizeof(logMsg),
            COMBAT_DEATH "â˜… %së¥¼ ì²˜ì¹˜í–ˆë‹¤! â˜…" COLOR_RESET, e->name);
        ui_add_log(logMsg);

        // â˜… ì´í™íŠ¸ ì œê±°
        ui_hide_combat_effect();
        return;
    }

    // â˜… ì  ë°˜ê²© ì „ ì´í™íŠ¸ ë³€ê²½
    //ui_clear_combat_effect(107, 2);

    // ì  ë°˜ê²© ì´í™íŠ¸ (ë°©íŒ¨)
    //console_goto(107, 2);
    //printf(COLOR_BRIGHT_BLUE "  ğŸ›¡" COLOR_RESET);
    //console_goto(107, 3);
    //printf(COLOR_BRIGHT_BLUE " ğŸ›¡ğŸ›¡ğŸ›¡" COLOR_RESET);
    //console_goto(107, 4);
    //printf(COLOR_BRIGHT_BLUE "ğŸ›¡ğŸ›¡ğŸ›¡ğŸ›¡ğŸ›¡" COLOR_RESET);

    // â˜…â˜…â˜… ì  ë°˜ê²© - ëœë¤ ë°ë¯¸ì§€ â˜…â˜…â˜…
    int enemyAttack = e->attackMin + rand() % (e->attackMax - e->attackMin + 1);
    int enemyDamage = enemyAttack - p->defense;
    if (enemyDamage < 1) enemyDamage = 1;

    p->hp -= enemyDamage;

    // â˜… ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ê°•ì¡°
    snprintf(logMsg, sizeof(logMsg),
        COMBAT_ENEMY "â˜  %sì˜ ë°˜ê²©! " COMBAT_DAMAGE "%d ë°ë¯¸ì§€!" COLOR_RESET " (í”Œë ˆì´ì–´ HP: %d/%d)",
        e->name, enemyDamage, p->hp > 0 ? p->hp : 0, p->maxHp);
    ui_add_log(logMsg);

    //Sleep(100);

    // â˜… ì´í™íŠ¸ ì œê±°
    //ui_clear_combat_effect(107, 2);

    // í”Œë ˆì´ì–´ ì‚¬ë§ ì²´í¬
    if (p->hp <= 0) {
        ui_add_log("ë‹¹ì‹ ì€ ì“°ëŸ¬ì¡ŒìŠµë‹ˆë‹¤...");
    }
}

------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\logic\combat.h
[FILE NAME] combat.h
------------------------------------------------------------

// core/combat.h
#ifndef COMBAT_H
#define COMBAT_H

#include "../../entity/player.h"
#include "../../entity/enemy.h"
#include "../../world/map.h"

// ì¸ì ‘ ì  ì²´í¬ ë° ë©”ì‹œì§€ ìƒì„±
void combat_check_nearby_enemy(Map* m , Player* p);

// ì „íˆ¬ ì‹œì‘
void combat_attack_enemy(Player* p , Enemy* e , Map* m);

#endif

------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\system\context.h
[FILE NAME] context.h
------------------------------------------------------------

#ifndef CONTEXT_H
#define CONTEXT_H

#include "../../world/map.h"
#include "../../entity/player.h"

// ê²Œì„ì˜ ì „ì²´ ìƒíƒœë¥¼ ë‹´ëŠ” êµ¬ì¡°ì²´
typedef struct {
    Map map;
    Player player;
    
    int isRunning;      // ê²Œì„ ë£¨í”„ ì‹¤í–‰ ì—¬ë¶€
    
    // ì´ë™ ê´€ë ¨
    int prevX;
    int prevY;

    // ëŒ€í™” ëª¨ë“œ ê´€ë ¨
    int inDialogue;
    NPC* currentNPC;

} GameState;

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\system\game_input.c
[FILE NAME] game_input.c
------------------------------------------------------------

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <conio.h>
#include <ctype.h>
#include "game_internal.h"
#include "../ui/ui.h"
#include "../logic/combat.h"
#include "../../cinematic/cinematic.h"
#include "../../world/glyph.h"

// ì…ë ¥ ì²˜ë¦¬ ë° ë¡œì§ ì—…ë°ì´íŠ¸
void game_process_input(GameState* state) {
    // 1. ëŒ€í™” ëª¨ë“œ ì²˜ë¦¬
    if (state->inDialogue && state->currentNPC != NULL) {
        int cmd = _getch();
        cmd = tolower(cmd);

        if (cmd == '0') {
            if (state->currentNPC->currentDialogue == state->currentNPC->dialogueCount - 1) {
                // ëŒ€í™” ë
                state->currentNPC->currentDialogue = 0;
                state->inDialogue = 0;
                state->currentNPC = NULL;

                ui_clear_dialogue_area();
                // UI ë³µêµ¬ëŠ” game_render í˜¹ì€ ë‹¤ìŒ í”„ë ˆì„ì—ì„œ ì²˜ë¦¬ë¨
                ui_draw_stats(&state->player);
                ui_draw_equipment(&state->player);
                ui_draw_log();
            }
            else {
                // ë‹¤ìŒ ëŒ€í™”
                npc_next_dialogue(state->currentNPC);
                ui_draw_dialogue(state->currentNPC);
            }
        }
        else if (cmd == 't' && state->currentNPC->canTrade) {
            ui_add_log(COLOR_YELLOW "ê±°ë˜ ì‹œìŠ¤í…œì€ ê³§ ì¶”ê°€ë©ë‹ˆë‹¤!" COLOR_RESET);
            ui_draw_log();
        }
        else if (cmd == 'x' || cmd == 27) {
            state->currentNPC->currentDialogue = 0;
            state->inDialogue = 0;
            state->currentNPC = NULL;
            
            ui_clear_dialogue_area();
            ui_draw_stats(&state->player);
            ui_draw_equipment(&state->player);
        }
        return;
    }

    // 2. ì¼ë°˜ ê²Œì„ ëª¨ë“œ
    if (state->player.hp <= 0) {
        cinematic_play_ending(1);
        state->isRunning = 0;
        return;
    }

    int cmd = _getch();
    if (cmd == 0 || cmd == 224) {
        cmd = _getch();
        switch (cmd) {
        case 72: cmd = 'w'; break;
        case 80: cmd = 's'; break;
        case 75: cmd = 'a'; break;
        case 77: cmd = 'd'; break;
        }
    }
    cmd = tolower(cmd);

    if (cmd == 'q') {
        ui_add_log(COLOR_BRIGHT_RED "ì •ë§ ì¢…ë£Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (Y: ì¢…ë£Œ, ê·¸ ì™¸: ì·¨ì†Œ)" COLOR_RESET);
        ui_draw_log();
        ui_present();

        int confirm = _getch();
        confirm = tolower(confirm);
        if (confirm == 'y') {
            state->isRunning = 0;
        } else {
            ui_add_log("ì¢…ë£Œë¥¼ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.");
        }
        return;
    }

    // í–‰ë™ ì „ ì´í™íŠ¸ í´ë¦¬ì–´
    ui_hide_combat_effect();

    int targetX = state->player.x;
    int targetY = state->player.y;

    switch (cmd) {
    case 'w': targetY--; break;
    case 's': targetY++; break;
    case 'a': targetX--; break;
    case 'd': targetX++; break;
    }

    // ì´ë™ ì²˜ë¦¬
    player_move(&state->player, &state->map, cmd);

    // ìƒí˜¸ì‘ìš© (0 í‚¤)
    if (cmd == '0') {
        // NPC
        NPC* npc = map_get_npc_at(&state->map, targetX, targetY);  // ë‚´ ìœ„ì¹˜ ê¸°ë°˜ì´ ì•„ë‹Œ ì´ë™ ë°©í–¥?
        // ê¸°ì¡´ game.c ë¡œì§: targetEnemyëŠ” ì´ë™ ì˜ˆì¸¡ìš©ì´ì—ˆì§€ë§Œ
        // '0'í‚¤ëŠ” map_get_npc_at(..., tx, ty) ??? 
        // ê¸°ì¡´ ì½”ë“œë¥¼ ìì„¸íˆ ë³´ë©´:
        // int tx = player.x + player.dirX; int ty = ...
        // '0' ëˆ„ë¥´ë©´ "map_get_npc_at(&map, tx, ty)" -> ë°”ë¼ë³´ëŠ” ë°©í–¥ì˜ NPCì™€ ìƒí˜¸ì‘ìš©
        // ë¦¬íŒ©í† ë§ ì‹œ ì£¼ì˜: cmdê°€ 0ì¼ ë• ì´ë™ì´ ì•„ë‹ˆë¯€ë¡œ targetX/Yê°€ ì˜ë¯¸ê°€ ë‹¤ë¦„.
        // ë°”ë¼ë³´ëŠ” ë°©í–¥ ê³„ì‚° í•„ìš”
        
        int tx = state->player.x + state->player.dirX;
        int ty = state->player.y + state->player.dirY;

        NPC* interactNpc = map_get_npc_at(&state->map, tx, ty);
        if (interactNpc != NULL) {
            if (interactNpc->useDialogueBox) {
                state->inDialogue = 1;
                state->currentNPC = interactNpc;
                ui_clear_dialogue_area();
                ui_draw_dialogue(interactNpc);
                
                char msg[128];
                snprintf(msg, sizeof(msg), "%sì™€ ëŒ€í™”ë¥¼ ì‹œì‘í–ˆë‹¤.", interactNpc->name);
                ui_add_log(msg);
                ui_draw_log();
            } else {
                const char* dialogue = npc_get_dialogue(interactNpc);
                char msg[256];
                snprintf(msg, sizeof(msg), COLOR_BRIGHT_CYAN "ğŸ’¬ %s: " COLOR_RESET "ã€Œ%sã€", interactNpc->name, dialogue);
                ui_add_log(msg);
                npc_next_dialogue(interactNpc);
            }
        }

        // Chest
        Chest* chest = map_get_chest_at(&state->map, tx, ty);
        if (chest != NULL && !chest->isOpened) {
            chest->isOpened = 1;
            player_apply_item(&state->player, chest->itemType, chest->itemName);
            char msg[128];
            snprintf(msg, sizeof(msg), COLOR_BRIGHT_YELLOW "ğŸ“¦ ìƒìë¥¼ ì—´ì—ˆë‹¤! â†’ %s íšë“!" COLOR_RESET, chest->itemName);
            ui_add_log(msg);
            ui_render_map_viewport(&state->map, &state->player);
            ui_draw_equipment(&state->player);
        }
    }

    // ì£¼ë³€ ì²´í¬
    combat_check_nearby_enemy(&state->map, &state->player);

    NPC* nearNpc = map_get_adjacent_npc(&state->map, state->player.x, state->player.y);
    if (nearNpc != NULL) {
        char msg[128];
        snprintf(msg, sizeof(msg), "%sì´(ê°€) ê°€ê¹Œì´ ìˆë‹¤. [0] í‚¤ë¡œ ëŒ€í™”í•  ìˆ˜ ìˆë‹¤.", nearNpc->name);
        ui_add_log(msg);
    }
    Chest* nearChest = map_get_adjacent_chest(&state->map, state->player.x, state->player.y);
    if (nearChest != NULL && !nearChest->isOpened) {
        ui_add_log("ê°€ê¹Œìš´ ê³³ì— ìƒìê°€ ìˆë‹¤. [0] í‚¤ë¡œ ì—´ ìˆ˜ ìˆë‹¤.");
    }
}


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\system\game_internal.h
[FILE NAME] game_internal.h
------------------------------------------------------------

#ifndef GAME_INTERNAL_H
#define GAME_INTERNAL_H

#include "context.h"

// ì…ë ¥ ì²˜ë¦¬
void game_process_input(GameState* state);

// í™”ë©´ ë Œë”ë§
void game_render(GameState* state);

// ë©”ì¸ ë£¨í”„
void game_loop(GameState* state);

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\system\game_loop.c
[FILE NAME] game_loop.c
------------------------------------------------------------

#include "game_internal.h"
#include <windows.h> // Sleep? or just raw loop

void game_loop(GameState* state) {
    state->isRunning = 1;

    // ì´ˆê¸° ìƒíƒœ ë Œë”ë§
    game_render(state);

    while (state->isRunning) {
        // ì…ë ¥ ì²˜ë¦¬
        game_process_input(state);

        // ì—…ë°ì´íŠ¸ (í˜„ì¬ ë¡œì§ìƒ inputì—ì„œ ëŒ€ë¶€ë¶„ ì²˜ë¦¬ë˜ì§€ë§Œ ë‚˜ì¤‘ì— ë¶„ë¦¬ ê°€ëŠ¥)
        // game_update(state); 

        // ë Œë”ë§
        game_render(state);
    }
}


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\system\game_render.c
[FILE NAME] game_render.c
------------------------------------------------------------

#include <stddef.h> // NULL ì •ì˜ ì¶”ê°€
#include "game_internal.h"
#include "../ui/ui.h"
#include "../../world/glyph.h"

// í™”ë©´ ë Œë”ë§ (ì´ˆê¸°í™” ë° ì—…ë°ì´íŠ¸)
void game_render(GameState* state) {
    // 1. ë²„í¼ í´ë¦¬ì–´
    ui_clear_buffer();

    // 2. ë·°í¬íŠ¸ ê·¸ë¦¬ê¸° (í•­ìƒ ê·¸ë¦¼)
    ui_render_map_viewport(&state->map, &state->player);

    // 3. UI ê·¸ë¦¬ê¸° (í•­ìƒ ê·¸ë¦¼ - ëŒ€í™”ì°½ì´ ì˜¤ë²„ë ˆì´ë¨)
    if (!state->inDialogue) {
        ui_draw_stats(&state->player);
        ui_draw_equipment(&state->player);
    } else {
        if (state->currentNPC != NULL) {
            ui_draw_dialogue(state->currentNPC);
        }
    }
    ui_draw_log();
    // ëŒ€í™” ì¤‘ì¼ ë•ŒëŠ” ui_draw_dialogueê°€ í•„ìš”í•˜ì§€ë§Œ, 
    // ê¸°ì¡´ ë¡œì§ì—ì„œëŠ” input ë£¨í”„ ì•ˆì—ì„œ ê·¸ë ¸ì„ ìˆ˜ ìˆìŒ.
    // í•˜ì§€ë§Œ ë”ë¸” ë²„í¼ë§ì—ì„œëŠ” ë§¤ í”„ë ˆì„ ë‹¤ ê·¸ë¦¬ëŠ” ê²Œ ì •ì„.
    // game_input.cì—ì„œ ì…ë ¥ì„ ëŒ€ê¸°í•˜ë©´ì„œ ê·¸ë¦¬ëŠ”ì§€ í™•ì¸ í•„ìš”.
    // ì¼ë‹¨ ì—¬ê¸°ì„œëŠ” ê¸°ë³¸ UIë§Œ ê·¸ë¦°ë‹¤.
    
    // 4. í™”ë©´ ì¶œë ¥ (Present)
    ui_present();
}


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\layout.h
[FILE NAME] layout.h
------------------------------------------------------------

#ifndef UI_LAYOUT_H
#define UI_LAYOUT_H

// Screen Dimensions (Expanded & Centered)
// Screen Dimensions (Expanded & Centered)
#define SCREEN_W 210
#define SCREEN_H 55

#define SCREEN_PADDING_LEFT 20
#define SCREEN_PADDING_TOP 6

// Map Viewport
#define VIEWPORT_X (SCREEN_PADDING_LEFT)
#define VIEWPORT_Y (SCREEN_PADDING_TOP)
#define VIEWPORT_W 120 
#define VIEWPORT_H 30

// Right Side Panels (Status / Equipment / Dialogue)
#define PANEL_X (VIEWPORT_X + VIEWPORT_W)
#define PANEL_WIDTH 52

// Status Panel
#define STATUS_X PANEL_X
#define STATUS_Y (SCREEN_PADDING_TOP)
#define STATUS_W PANEL_WIDTH
#define STATUS_H 14

// Equipment Panel
#define EQUIP_X PANEL_X
#define EQUIP_Y (STATUS_Y + STATUS_H)
#define EQUIP_W PANEL_WIDTH
#define EQUIP_H 16

// Dialogue Panel (Overlays Status + Equip)
#define DIALOGUE_X PANEL_X
#define DIALOGUE_Y (SCREEN_PADDING_TOP)
#define DIALOGUE_W PANEL_WIDTH
#define DIALOGUE_H (STATUS_H + EQUIP_H)

// Log Panel
#define LOG_X (SCREEN_PADDING_LEFT)
#define LOG_Y (VIEWPORT_Y + VIEWPORT_H) // +2 padding removed
#define LOG_W (VIEWPORT_W + PANEL_WIDTH)
#define LOG_H 14
#define LOG_LINES 200

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\ui.h
[FILE NAME] ui.h
------------------------------------------------------------

#ifndef UI_H
#define UI_H

// Backend
#include "layout.h"
#include "backend/buffer.h"
#include "backend/console.h"

// Text
#include "text/glyph.h"
#include "text/render.h"

// Widgets
#include "widgets/box.h"

// Panels
#include "panels/stats.h"
#include "panels/equipment.h"
#include "panels/dialogue.h"
#include "panels/effect.h"

// View
#include "view/viewport.h"

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\backend\buffer.c
[FILE NAME] buffer.c
------------------------------------------------------------

#define _CRT_SECURE_NO_WARNINGS
#include "buffer.h"
#include "../layout.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

Cell* screenBuffer = NULL;
int bufferWidth = 0;
int bufferHeight = 0;
char globalColor[32] = "\033[0m"; 

void ui_init_buffer(void) {
    // 1. Setup Console
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    DWORD dwMode = 0;
    GetConsoleMode(hOut, &dwMode);
    dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
    SetConsoleMode(hOut, dwMode);
    
    // Set UTF-8 Output
    SetConsoleOutputCP(CP_UTF8);

    // Fullscreen setup (Alt+Enter simulation)
    keybd_event(VK_MENU, 0x38, 0, 0);
    keybd_event(VK_RETURN, 0x1c, 0, 0);
    keybd_event(VK_RETURN, 0x1c, KEYEVENTF_KEYUP, 0);
    keybd_event(VK_MENU, 0x38, KEYEVENTF_KEYUP, 0);
    Sleep(100);

    // 2. Allocate Buffer
    bufferWidth = SCREEN_W; 
    bufferHeight = SCREEN_H; 
    screenBuffer = (Cell*)malloc(sizeof(Cell) * bufferWidth * bufferHeight);
    
    // Hide Cursor
    CONSOLE_CURSOR_INFO info;
    info.dwSize = 1;
    info.bVisible = FALSE;
    SetConsoleCursorInfo(hOut, &info);

    ui_clear_buffer();
}

void ui_clear_buffer(void) {
    if (!screenBuffer) return;
    for (int i = 0; i < bufferWidth * bufferHeight; i++) {
        strcpy(screenBuffer[i].ch, " ");
        strcpy(screenBuffer[i].color, "\033[0m"); 
        screenBuffer[i].isDoubleWidth = 0;
    }
    strcpy(globalColor, "\033[0m"); // Reset global color state
}

void ui_present(void) {
    if (!screenBuffer) return;

    // Estimate buffer size: Width * Height * (Char(4) + Color(12)) + Newlines
    static char* outBuf = NULL;
    static int outBufSize = 0;
    int requiredSize = bufferWidth * bufferHeight * 20; 
    
    if (outBuf == NULL || outBufSize < requiredSize) {
        free(outBuf);
        outBuf = (char*)malloc(requiredSize);
        outBufSize = requiredSize;
    }

    char* p = outBuf;
    
    // Reset cursor to top-left
    p += sprintf(p, "\033[H"); 
    
    char lastColor[32] = "";
    
    for (int y = 0; y < bufferHeight; y++) {
        for (int x = 0; x < bufferWidth; x++) {
            int idx = y * bufferWidth + x;
            Cell* c = &screenBuffer[idx];
            
            if (c->isDoubleWidth == -1) continue; // Skip padding
            
            // Only print color if changed
            if (strcmp(c->color, lastColor) != 0) {
                p += sprintf(p, "\033[0m%s", c->color); // Reset before applying new color to avoid BG bleed
                strcpy(lastColor, c->color);
            }
            
            p += sprintf(p, "%s", c->ch);
        }
        if (y < bufferHeight - 1) {
             p += sprintf(p, "\n");
        }
    }
    
    // Write whole frame at once
    DWORD written;
    WriteConsoleA(GetStdHandle(STD_OUTPUT_HANDLE), outBuf, (DWORD)(p - outBuf), &written, NULL);
}

void ui_draw_char_at(int x, int y, const char* c, const char* color) {
    if (x < 0 || x >= bufferWidth || y < 0 || y >= bufferHeight) return;
    
    int index = y * bufferWidth + x;
    
    strncpy(screenBuffer[index].ch, c, 4);
    screenBuffer[index].ch[4] = '\0';
    
    if (color) strcpy(screenBuffer[index].color, color);
    else strcpy(screenBuffer[index].color, "\033[0m");
    
    screenBuffer[index].isDoubleWidth = 0; 
}


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\backend\buffer.h
[FILE NAME] buffer.h
------------------------------------------------------------

#ifndef UI_BUFFER_H
#define UI_BUFFER_H

#include <windows.h>

typedef struct {
    char ch[5];        // UTF-8 char (max 4 bytes + null)
    char color[32];    // ANSI Color char string
    int isDoubleWidth; // 0=single, 1=double, -1=padding
} Cell;

extern Cell* screenBuffer;
extern int bufferWidth;
extern int bufferHeight;
extern char globalColor[32];

void ui_init_buffer(void);
void ui_clear_buffer(void);
void ui_present(void);

// Basic low-level drawing (often used internally but exposed if needed)
void ui_draw_char_at(int x, int y, const char* c, const char* color);

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\backend\console.c
[FILE NAME] console.c
------------------------------------------------------------

#include "console.h"
#include "buffer.h"
#include <windows.h>

void console_clear_fast(void) {
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(hOut, &csbi);

    DWORD cellCount = csbi.dwSize.X * csbi.dwSize.Y;
    DWORD count;
    COORD homeCoords = { 0, 0 };

    FillConsoleOutputCharacter(hOut, ' ', cellCount, homeCoords, &count);
    FillConsoleOutputAttribute(hOut, csbi.wAttributes, cellCount, homeCoords, &count);
    SetConsoleCursorPosition(hOut, homeCoords);
}

void console_goto(int x, int y) {
    COORD pos = { x, y };
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos);
}

void ui_init(void) {
    ui_init_buffer();
}


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\backend\console.h
[FILE NAME] console.h
------------------------------------------------------------

#ifndef UI_CONSOLE_H
#define UI_CONSOLE_H

void console_clear_fast(void);
void console_goto(int x, int y);
void ui_init(void);

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\panels\dialogue.c
[FILE NAME] dialogue.c
------------------------------------------------------------

#define _CRT_SECURE_NO_WARNINGS
#include "dialogue.h"
#include "../text/render.h"
#include "../text/glyph.h"
#include "../widgets/box.h"
#include "../../../world/glyph.h" // For Colors
#include <stdio.h>
#include <string.h>

#include "../layout.h"
static char log_buf[LOG_LINES][256];
static int log_index = 0;

void ui_draw_dialogue(const NPC* npc) {
    int x = DIALOGUE_X;
    int y = DIALOGUE_Y;
    int w = DIALOGUE_W;
    int h = DIALOGUE_H;
    
    ui_draw_box(x, y, w, h, "ëŒ€í™”");

    // Name
    char nameBuf[256];
    snprintf(nameBuf, sizeof(nameBuf), "ğŸ’¬ %s", npc->name);
    ui_draw_text_clipped(x + 2, y + 1, w - 4, nameBuf, NULL);

    // Separator
    ui_draw_str_at(x, y + 2, "â”œ", NULL);
    for (int i = 1; i < w - 1; i++) ui_draw_str_at(x + i, y + 2, "â”€", NULL);
    ui_draw_str_at(x + w - 1, y + 2, "â”¤", NULL);

    // Dialogue Content
    const char* dialogue = npc->dialogues[npc->currentDialogue];
    int lineStart = 0;
    int lineNum = 0;
    int maxLines = h - 6;

    for (int i = 3; i < h - 3 && lineNum < maxLines; i++) {
        char lineBuf[256] = "";  // Temporary buffer for current line
        
        int currentWidth = 0;
        const char* dialoguePtr = dialogue + lineStart;
        int maxTextWidth = w - 4; // CONTENT_WIDTH - 2 due to padding

        int charsProcessed = 0;

        while (*dialoguePtr) {
            // ANSI Check
            if (*dialoguePtr == '\033' || *dialoguePtr == 0x1B) {
                // Copy ANSI code to buffer
                const char* ansiStart = dialoguePtr;
                dialoguePtr++;
                if (*dialoguePtr == '[') {
                    while (*dialoguePtr && *dialoguePtr != 'm') dialoguePtr++;
                    if (*dialoguePtr == 'm') dialoguePtr++;
                }
                int codeBytes = (int)(dialoguePtr - ansiStart);
                if (strlen(lineBuf) + codeBytes < sizeof(lineBuf) - 1) {
                    strncat(lineBuf, ansiStart, codeBytes);
                }
                charsProcessed += codeBytes;
                continue;
            }
            
            // Newline/Tab Check - Replace with space to prevent layout breakage
            if (*dialoguePtr == '\n' || *dialoguePtr == '\r' || *dialoguePtr == '\t') {
                int charBytes = 1;
                int charW = 1;
                
                if (currentWidth + charW > maxTextWidth) break;
                
                if (strlen(lineBuf) + 1 < sizeof(lineBuf) - 1) {
                    strcat(lineBuf, " ");
                }
                currentWidth += charW;
                charsProcessed += charBytes;
                dialoguePtr += charBytes;
                continue;
            }

            // Width Check
            int charW = 1;
            int charBytes = 1;
            
            ui_get_glyph_info(dialoguePtr, &charBytes, &charW);
             
             if (currentWidth + charW > maxTextWidth) break;
             
             if (strlen(lineBuf) + charBytes < sizeof(lineBuf) - 1) {
                 strncat(lineBuf, dialoguePtr, charBytes);
             }
             currentWidth += charW;
             charsProcessed += charBytes;
             dialoguePtr += charBytes;
        }
        
        ui_draw_text_clipped(x + 2, y + i, w - 4, lineBuf, NULL);
        
        lineStart += charsProcessed;
        lineNum++;
        if (dialogue[lineStart] == '\0') break;
    }

    // Bottom Separator
    ui_draw_str_at(x, y + h - 3, "â”œ", NULL);
    for (int i = 1; i < w - 1; i++) ui_draw_str_at(x + i, y + h - 3, "â”€", NULL);
    ui_draw_str_at(x + w - 1, y + h - 3, "â”¤", NULL);

    // Buttons
    char buttonText[64];
    if (npc->currentDialogue < npc->dialogueCount - 1) {
        if (npc->canTrade) snprintf(buttonText, sizeof(buttonText), " [0]ë‹¤ìŒ  [T]ê±°ë˜  [X]ë‹«ê¸°");
        else snprintf(buttonText, sizeof(buttonText), " [0]ë‹¤ìŒ  [X]ë‹«ê¸°");
    }
    else {
        if (npc->canTrade) snprintf(buttonText, sizeof(buttonText), " [0]ë  [T]ê±°ë˜  [X]ë‹«ê¸°");
        else snprintf(buttonText, sizeof(buttonText), " [0]ë  [X]ë‹«ê¸°");
    }
    ui_draw_text_clipped(x + 1, y + h - 2, w - 2, buttonText, NULL);
}

void ui_clear_dialogue_area(void) {
    int x = DIALOGUE_X;
    int y = DIALOGUE_Y;
    int w = DIALOGUE_W;
    int h = DIALOGUE_H;
    for (int i = 0; i < h; i++) {
        char spaces[128] = "";
        for (int j = 0; j < w; j++) strcat(spaces, " ");
        ui_draw_str_at(x, y + i, spaces, NULL);
    }
}

void ui_add_log(const char* msg) {
    snprintf(log_buf[log_index], sizeof(log_buf[log_index]), "%s", msg);
    log_index = (log_index + 1) % LOG_LINES;
}

void ui_draw_log(void) {
    int x = LOG_X;
    int y = LOG_Y;
    int w = LOG_W;
    int h = LOG_H;

    ui_draw_box(x, y, w, h, "ëŒ€í™”");

    int start = (log_index - (h - 2) + LOG_LINES) % LOG_LINES;
    for (int i = 0; i < h - 2; i++) {
        // Log text with potential ANSI
        const char* logText = log_buf[(start + i) % LOG_LINES];

        // â˜… í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸° - ì‹¤ì œ ì‚¬ìš©ëœ í‘œì‹œ í­ì„ ë°˜í™˜ë°›ìŒ
        int actualWidth = ui_draw_text_clipped(x + 2, y + 1 + i, w - 4, logText, NULL);

        // â˜… ë‚¨ì€ ê³µê°„ ëª…ì‹œì ìœ¼ë¡œ ê³µë°±ìœ¼ë¡œ ì±„ìš°ê¸° (ì˜¤ë¥¸ìª½ í…Œë‘ë¦¬ ì •ë ¬)
        int textEndX = x + 2 + actualWidth;
        for (int j = textEndX; j < x + w - 2; j++) {
            ui_draw_str_at(j, y + 1 + i, " ", NULL);
        }
    }

    // â˜… í…Œë‘ë¦¬ ëª¨ì„œë¦¬ ë³´í˜¸
    const char* borderCol = "\033[0m";
    ui_draw_str_at(x, y, "â”Œ", borderCol);
    ui_draw_str_at(x + w - 1, y, "â”", borderCol);
    ui_draw_str_at(x, y + h - 1, "â””", borderCol);
    ui_draw_str_at(x + w - 1, y + h - 1, "â”˜", borderCol);
}


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\panels\dialogue.h
[FILE NAME] dialogue.h
------------------------------------------------------------

#ifndef UI_DIALOGUE_H
#define UI_DIALOGUE_H

#include "../../../entity/npc.h"

void ui_draw_dialogue(const NPC* npc);
void ui_clear_dialogue_area(void);
void ui_add_log(const char* msg);
void ui_draw_log(void);

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\panels\effect.c
[FILE NAME] effect.c
------------------------------------------------------------

#include "effect.h"
#include "../text/render.h"
#include "../../../world/glyph.h" // For Colors

static int combatEffectFrames = 0;

void ui_show_combat_effect(void) {
    combatEffectFrames = 10; // 10 frames duration
    // No direct draw here, logic handles update in gameloop which calls render
}

void ui_hide_combat_effect(void) {
    combatEffectFrames = 0;
}

void ui_draw_combat_effect_overlay_if_active(int statusX, int statusY) {
    if (combatEffectFrames > 0) {
        int ex = statusX + 25;
        int ey = statusY + 2;

        ui_draw_str_at(ex, ey - 1, "ì „íˆ¬ì¤‘", COLOR_BRIGHT_RED);
        ui_draw_str_at(ex, ey,     "  âš”",   COLOR_BRIGHT_RED);
        ui_draw_str_at(ex, ey + 1, " âš”âš”âš”", COLOR_BRIGHT_RED);
        ui_draw_str_at(ex, ey + 2, "âš”âš”âš”âš”âš”", COLOR_BRIGHT_RED);
        ui_draw_str_at(ex, ey + 3, " âš”âš”âš”", COLOR_BRIGHT_RED);
        ui_draw_str_at(ex, ey + 4, "  âš”",   COLOR_BRIGHT_RED);

        combatEffectFrames--;
    }
}


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\panels\effect.h
[FILE NAME] effect.h
------------------------------------------------------------

#ifndef UI_EFFECT_H
#define UI_EFFECT_H

void ui_show_combat_effect(void);
void ui_hide_combat_effect(void);
void ui_draw_combat_effect_overlay_if_active(int statusX, int statusY);

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\panels\equipment.c
[FILE NAME] equipment.c
------------------------------------------------------------

#define _CRT_SECURE_NO_WARNINGS
#include "equipment.h"
#include "../text/render.h"
#include "../widgets/box.h"
#include <stdio.h>

#include "../layout.h"

void ui_draw_equipment(const Player* p) {
    int x = EQUIP_X;
    int y = EQUIP_Y;
    int w = EQUIP_W;
    int h = EQUIP_H;

    ui_draw_box(x, y, w, h, "ì¥ë¹„");

    char buf[128];
    snprintf(buf, sizeof(buf), " ë¬´ê¸°:    %s", p->weaponName);
    ui_draw_text_clipped(x + 2, y + 2, w - 4, buf, NULL);

    snprintf(buf, sizeof(buf), " ë°©ì–´êµ¬:  %s", p->armorName);
    ui_draw_text_clipped(x + 2, y + 3, w - 4, buf, NULL);

    snprintf(buf, sizeof(buf), " ì•„ì´í…œ:  %s", p->item1);
    ui_draw_text_clipped(x + 2, y + 4, w - 4, buf, NULL);

    // â˜… í…Œë‘ë¦¬ ëª¨ì„œë¦¬ ë³´í˜¸
    const char* borderCol = "\033[0m";
    ui_draw_str_at(x, y, "â”Œ", borderCol);
    ui_draw_str_at(x + w - 1, y, "â”", borderCol);
    ui_draw_str_at(x, y + h - 1, "â””", borderCol);
    ui_draw_str_at(x + w - 1, y + h - 1, "â”˜", borderCol);
}


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\panels\equipment.h
[FILE NAME] equipment.h
------------------------------------------------------------

#ifndef UI_EQUIPMENT_H
#define UI_EQUIPMENT_H

#include "../../../entity/player.h"

void ui_draw_equipment(const Player* p);

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\panels\stats.c
[FILE NAME] stats.c
------------------------------------------------------------

#define _CRT_SECURE_NO_WARNINGS
#include "stats.h"
#include "../backend/buffer.h" // For globals/colors if needed, though render handles it
#include "../text/render.h"
#include "../text/glyph.h"
#include "../widgets/box.h"
#include "../../../world/glyph.h" // For constants if needed, though colors are standard
#include <stdio.h>
#include <string.h>

#include "../layout.h"

// Layout constants - Localized (removed)

extern int combatEffectFrames; // Accessed from effect.c ... wait, cyclic dependency or shared state?
// combatEffectFrames was static in ui.c. Now it belongs to effect module.
// ui_draw_stats draws the combat effect overlay? 
// Original code had `ui_draw_stats` drawing the combat overlay.
// Refactor: Move combat overlay drawing to `effect.c` and call it from `draw_stats` or separate?
// Better: `ui_draw_stats` calls `ui_draw_combat_effect_overlay` from `effect.h`.

#include "effect.h" // New dependency

void ui_draw_stats(const Player* p) {
    int x = STATUS_X;
    int y = STATUS_Y;
    int w = STATUS_W;
    int h = STATUS_H;
    
    ui_draw_box(x, y, w, h, "ìƒíƒœ");

    char buf[128];

    // â˜… HP Bar - ê°œë³„ ë¬¸ìë¡œ ê·¸ë¦¬ê¸° (ì •í™•í•œ í­ ì œì–´)
    ui_draw_str_at(x + 2, y + 2, "HP: ", NULL);
    int hpBars = (p->hp * 10) / p->maxHp;
    if (hpBars > 10) hpBars = 10;
    int barX = x + 2 + 4;  // "HP: " = 4ì¹¸

    // ìˆ˜ì • - ë¬¸ìì—´ë¡œ í•œ ë²ˆì— ê·¸ë¦¬ê¸°
    char hpBarStr[64] = "";
    for (int i = 0; i < 10; i++) {
        strcat(hpBarStr, i < hpBars ? "â–ˆ" : "â–‘");
    }
    ui_draw_str_at(barX, y + 2, hpBarStr, NULL);
    int barEndX = barX + display_width(hpBarStr);  // ë™ì  ê³„ì‚°

    for (int i = barEndX; i < x + w - 2; i++) {
        ui_draw_str_at(i, y + 2, " ", NULL);
    }

    // HP Text
    snprintf(buf, sizeof(buf), "     %3d / %3d", p->hp, p->maxHp);
    ui_draw_text_clipped(x + 2, y + 3, w - 4, buf, NULL);

    // Attack
    snprintf(buf, sizeof(buf), " ê³µê²©ë ¥: %2d~%2d", p->attackMin, p->attackMax);
    ui_draw_text_clipped(x + 2, y + 5, w - 4, buf, NULL);

    // Defense
    snprintf(buf, sizeof(buf), " ë°©ì–´ë ¥:  %3d", p->defense);
    ui_draw_text_clipped(x + 2, y + 6, w - 4, buf, NULL);

    // â˜… Direction - ê°œë³„ ì¶œë ¥ + ê³µë°± ì±„ìš°ê¸°
    const char* arrow = " ";
    if (p->dirY < 0) arrow = "â†‘";
    else if (p->dirY > 0) arrow = "â†“";
    else if (p->dirX < 0) arrow = "â†";
    else if (p->dirX > 0) arrow = "â†’";

    // ìˆ˜ì • - í•œ ë¬¸ìì—´ë¡œ ê·¸ë¦¬ê³  ë™ì  ê³„ì‚°
    char dirLine[64];
    snprintf(dirLine, sizeof(dirLine), " ë°©í–¥:    %s", arrow);
    ui_draw_str_at(x + 2, y + 7, dirLine, NULL);
    // ë°©í–¥ ë’¤ ê³µë°± (ë™ì  ê³„ì‚°)
    int dirEndX = x + 2 + display_width(dirLine);
    for (int i = dirEndX; i < x + w - 1; i++) {
        ui_draw_str_at(i, y + 7, " ", NULL);
    }

    ui_draw_combat_effect_overlay_if_active(x, y);

    // â˜… í…Œë‘ë¦¬ ëª¨ì„œë¦¬ ë³´í˜¸
    const char* borderCol = "\033[0m";
    ui_draw_str_at(x, y, "â”Œ", borderCol);
    ui_draw_str_at(x + w - 1, y, "â”", borderCol);
    ui_draw_str_at(x, y + h - 1, "â””", borderCol);
    ui_draw_str_at(x + w - 1, y + h - 1, "â”˜", borderCol);
}


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\panels\stats.h
[FILE NAME] stats.h
------------------------------------------------------------

#ifndef UI_STATS_H
#define UI_STATS_H

#include "../../../entity/player.h"

void ui_draw_stats(const Player* p);

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\text\glyph.c
[FILE NAME] glyph.c
------------------------------------------------------------

#include "glyph.h"

void ui_get_glyph_info(const char* s, int* byteLen, int* displayWidth) {
    unsigned char c = (unsigned char)*s;

    if (c < 128) {
        *byteLen = 1;
        *displayWidth = 1;
    }
    else if ((c & 0xE0) == 0xC0) {
        *byteLen = 2;
        *displayWidth = 2;
    }
    else if ((c & 0xF0) == 0xE0) {
        *byteLen = 3;
        if (c == 0xE2) {
            unsigned char c2 = (unsigned char)*(s + 1);

            // Block Elements (E2 96): â–ˆâ–‘ - í­ 2 â˜… ë¨¼ì € ì²´í¬!
            if (c2 == 0x96) {
                //*displayWidth = 2;
				*displayWidth = 1;
            }
            // Box Drawing (E2 94/95): â”€â”‚â”Œâ” - í­ 1
            else if (c2 == 0x94 || c2 == 0x95) {
                *displayWidth = 1;
            }
            // Arrows (E2 86): â†’â†‘â†“â† - í­ 1
            else if (c2 == 0x86) {
                *displayWidth = 1;
            }
            // Misc Symbols (E2 98/9A/9B): â˜ âš” ë“± - í­ 1
            else if (c2 == 0x98 || c2 == 0x9A || c2 == 0x9B) {
                *displayWidth = 1;
            }
            // General Punctuation (E2 80) - í­ 1
            else if (c2 == 0x80) {
                *displayWidth = 1;
            }
            // ê¸°íƒ€ - í­ 2
            else {
                *displayWidth = 2;
            }
        }
        else {
            *displayWidth = 2;
        }
    }
    else if ((c & 0xF8) == 0xF0) {
        *byteLen = 4;
        *displayWidth = 2;
    }
    else {
        *byteLen = 1;
        *displayWidth = 1;
    }
}

int display_width(const char* str) {
    int width = 0;
    const char* s = str;
    int byteLen, padding;
    
    while (*s) {
        if (*s == '\033' || *s == 0x1B) {
            s++;
            if (*s == '[') {
                s++;
                while (*s && *s != 'm') s++;
                if (*s == 'm') s++;
            }
            continue;
        }
        
        ui_get_glyph_info(s, &byteLen, &padding); // Use padding as temp width var
        width += padding;
        s += byteLen;
    }
    return width;
}


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\text\glyph.h
[FILE NAME] glyph.h
------------------------------------------------------------

#ifndef UI_GLYPH_H
#define UI_GLYPH_H

void ui_get_glyph_info(const char* s, int* byteLen, int* displayWidth);
int display_width(const char* str);

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\text\render.c
[FILE NAME] render.c
------------------------------------------------------------

#define _CRT_SECURE_NO_WARNINGS
#include "render.h"
#include "glyph.h"
#include "../backend/buffer.h" // Access screenBuffer, globalColor
#include <string.h>
#include <stdlib.h>

void ui_draw_str_at(int x, int y, const char* str, const char* color) {
    if (y < 0 || y >= bufferHeight) return;

    // Priority: Argument color > Embedded ANSI > Default
    // If 'color' arg is provided, use it.
    // If 'color' is NULL, we continue using globalColor (stateful).
    if (color) strcpy(globalColor, color);

    const char* s = str;
    int cx = x;

    while (*s) {
        if (cx >= bufferWidth) break;

        // ANSI Processing
        if (*s == '\033') {
            const char* end = strchr(s, 'm');
            if (end) {
                int len = (int)(end - s) + 1;
                if (len < 32) {
                    strncpy(globalColor, s, len);
                    globalColor[len] = '\0';
                }
                s = end + 1;
                continue;
            }
        }

        // Determine Byte Length & Width using Helper
        int byteLen = 1;
        int width = 1;
        
        ui_get_glyph_info(s, &byteLen, &width);
        
        // Write to Cell
        int index = y * bufferWidth + cx;
        
        strncpy(screenBuffer[index].ch, s, byteLen);
        screenBuffer[index].ch[byteLen] = '\0';
        strcpy(screenBuffer[index].color, globalColor);
        
        if (width == 2) {
            screenBuffer[index].isDoubleWidth = 1;
            cx++;
            if (cx < bufferWidth) {
                screenBuffer[index+1].isDoubleWidth = -1; // Padding
                screenBuffer[index+1].ch[0] = '\0';
                cx++;
            }
        } else {
            screenBuffer[index].isDoubleWidth = 0;
            cx++;
        }
        
        s += byteLen;
    }
}

int ui_draw_text_clipped(int x, int y, int maxWidth, const char* text, const char* color) {
    if (!text) return 0;

    int currentWidth = 0;
    const unsigned char* s = (const unsigned char*)text;
    int curX = x;

    while (*s) {
        if (currentWidth >= maxWidth) break;

        // Check ANSI
        if (*s == '\033' || *s == 0x1B) {
             const unsigned char* start = s;
             s++;
             if (*s == '[') {
                 while (*s && *s != 'm') s++;
                 if (*s == 'm') s++;
             }
             // Draw ANSI code directly (0 width)
             int len = (int)(s - start);
             char buf[32];
             if (len < 32) {
                 strncpy(buf, (const char*)start, len);
                 buf[len] = 0;
                 ui_draw_str_at(curX, y, buf, NULL); 
             }
             continue;
        }

        int charLen = 1;
        int charWidth = 1;

        ui_get_glyph_info((const char*)s, &charLen, &charWidth);

        if (currentWidth + charWidth > maxWidth) break;

        char buf[8] = {0};
        strncpy(buf, (const char*)s, charLen);

        ui_draw_str_at(curX, y, buf, color);

        curX += charWidth;
        currentWidth += charWidth;
        s += charLen;
    }

    return currentWidth; // Returns display width used
}


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\text\render.h
[FILE NAME] render.h
------------------------------------------------------------

#ifndef UI_RENDER_H
#define UI_RENDER_H

void ui_draw_str_at(int x, int y, const char* str, const char* color);
int ui_draw_text_clipped(int x, int y, int maxWidth, const char* text, const char* color);

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\view\viewport.c
[FILE NAME] viewport.c
------------------------------------------------------------

#define _CRT_SECURE_NO_WARNINGS
#include "viewport.h"
#include "../backend/buffer.h" // For globalColor reset
#include <string.h>

#include "../layout.h"

void ui_render_map_viewport(Map* m, Player* p) {
    // Reset color before map render to avoid bleed
    strcpy(globalColor, "\033[0m");
    map_draw_viewport(m, p, VIEWPORT_X, VIEWPORT_Y, 60, VIEWPORT_H);
}


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\view\viewport.h
[FILE NAME] viewport.h
------------------------------------------------------------

#ifndef UI_VIEWPORT_H
#define UI_VIEWPORT_H

#include "../../../world/map.h"
#include "../../../entity/player.h"

void ui_render_map_viewport(Map* m, Player* p);

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\widgets\box.c
[FILE NAME] box.c
------------------------------------------------------------

#include "box.h"
#include "../text/render.h"

void ui_draw_box(int x, int y, int w, int h, const char* title) {
    // Force default color for border
    const char* borderCol = "\033[0m"; 
    
    // Corners
    ui_draw_str_at(x, y, "â”Œ", borderCol);
    ui_draw_str_at(x + w - 1, y, "â”", borderCol);
    ui_draw_str_at(x, y + h - 1, "â””", borderCol);
    ui_draw_str_at(x + w - 1, y + h - 1, "â”˜", borderCol);

    // Top/Bottom edges
    for (int i = 1; i < w - 1; i++) {
        ui_draw_str_at(x + i, y, "â”€", borderCol);
        ui_draw_str_at(x + i, y + h - 1, "â”€", borderCol);
    }

    // Side edges
    for (int i = 1; i < h - 1; i++) {
        ui_draw_str_at(x, y + i, "â”‚", borderCol);
        ui_draw_str_at(x + w - 1, y + i, "â”‚", borderCol);
    }

    // Title
    if (title) {
        ui_draw_str_at(x + 1, y, "â”€ ", borderCol);

        // Draw title (use default color or bright white?)
        int titleActualWidth = ui_draw_text_clipped(x + 3, y, w - 5, title, "\033[97m"); // Bright White

        if (3 + titleActualWidth < w - 1) {
            ui_draw_str_at(x + 3 + titleActualWidth, y, " â”€", borderCol);
        }

        // â˜… ì˜¤ë¥¸ìª½ ìœ„ ëª¨ì„œë¦¬ ë³´í˜¸
        ui_draw_str_at(x + w - 1, y, "â”", borderCol);
    }

    // â˜… ì˜¤ë¥¸ìª½ ì•„ë˜ ëª¨ì„œë¦¬ ë³´í˜¸
    ui_draw_str_at(x + w - 1, y + h - 1, "â”˜", borderCol);
}


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\core\ui\widgets\box.h
[FILE NAME] box.h
------------------------------------------------------------

#ifndef UI_BOX_H
#define UI_BOX_H

void ui_draw_box(int x, int y, int w, int h, const char* title);

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\debug\debug.c
[FILE NAME] debug.c
------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include "debug.h"
#include "../core/ui/text/glyph.h"

void debug_console_info(void) {
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);

    // â˜… UTF-8 ì„¤ì • ë¨¼ì €!
    SetConsoleOutputCP(CP_UTF8);
    SetConsoleCP(CP_UTF8);

    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(hOut, &csbi);

    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘     ì½˜ì†” ìƒíƒœ ë””ë²„ê¹… ì •ë³´          â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");

    printf("ë²„í¼ í¬ê¸°:   %d x %d\n", csbi.dwSize.X, csbi.dwSize.Y);
    printf("ìœˆë„ìš° í¬ê¸°: %d x %d\n",
        csbi.srWindow.Right - csbi.srWindow.Left + 1,
        csbi.srWindow.Bottom - csbi.srWindow.Top + 1);
    printf("ì»¤ì„œ ìœ„ì¹˜:   (%d, %d)\n",
        csbi.dwCursorPosition.X, csbi.dwCursorPosition.Y);
    printf("\nìœˆë„ìš° ì¢Œí‘œ:\n");
    printf("  Left=%d, Top=%d\n", csbi.srWindow.Left, csbi.srWindow.Top);
    printf("  Right=%d, Bottom=%d\n", csbi.srWindow.Right, csbi.srWindow.Bottom);

    printf("\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n");
    printf("ì•„ë¬´ í‚¤ë‚˜ ëˆ„ë¥´ë©´ ê³„ì†...");
    _getch();
    printf("\n");
}

// Helper struct for test cases
typedef struct {
    const char* name;
    const char* str;
} GlyphTestCase;

void debug_glyph(void) {
    printf("=== Glyph Width Helper Debugger ===\n\n");

    GlyphTestCase tests[] = {
        {"ASCII 'A'", "A"},
        {"Korean 'í•œ'", "í•œ"},
        {"Box 'â”€'", "â”€"},
        {"Box 'â”‚'", "â”‚"},
        {"Box 'â”Œ'", "â”Œ"},
        {"Shape 'â– '", "â– "},
        {"Shape 'â–²'", "â–²"},
        {"Sword 'âš”'", "âš”"},
        {"Skull 'â˜ '", "â˜ "},
        {"Block 'â–ˆ'", "â–ˆ"},
        {"Shade 'â–‘'", "â–‘"},
        {"Arrow 'â†’'", "â†’"}
    };

    for (int i = 0; i < sizeof(tests) / sizeof(tests[0]); i++) {
        const char* name = tests[i].name;
        const char* s = tests[i].str;
        
        int len, width;
        ui_get_glyph_info(s, &len, &width);
        
        // Hex Byte printing
        printf("%-14s : %s [", name, s);
        for (int j = 0; j < len; j++) {
            printf("%02X", (unsigned char)s[j]);
            if (j < len - 1) printf(" ");
        }
        printf("] -> Len: %d, Width: %d\n", len, width);
    }
}

#ifdef UNIT_TEST_GLYPH
int main(void) {
    SetConsoleOutputCP(65001);
    debug_glyph();
    return 0;
}
#endif

------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\debug\debug.h
[FILE NAME] debug.h
------------------------------------------------------------

#pragma once
#ifndef DEBUG_H
#define DEBUG_H

// ì½˜ì†” ìƒíƒœ ì •ë³´ ì¶œë ¥
void debug_console_info(void);

// ê²Œì„ ìƒíƒœ ì •ë³´ ì¶œë ¥ (ë‚˜ì¤‘ì— ì¶”ê°€ ê°€ëŠ¥)
// void debug_game_state(void);
// void debug_player_info(const Player* p);

void debug_glyph(void);

#endif 


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\entity\chest.c
[FILE NAME] chest.c
------------------------------------------------------------

#include "chest.h"

void chest_init(Chest* c, int x, int y, char tile, const char* itemType, const char* itemName) {
    c->x = x;
    c->y = y;
    c->tile = tile;
    c->isOpened = 0;
    c->itemType = itemType;
    c->itemName = itemName;
}


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\entity\chest.h
[FILE NAME] chest.h
------------------------------------------------------------

#pragma once
#ifndef CHEST_H
#define CHEST_H

typedef struct {
	int x , y;
	int isOpened;          // 0 = ë‹«í˜, 1 = ì´ë¯¸ ì—´ë¦° ìƒì
	char tile;             // â˜… ë§µ ìƒì˜ íƒ€ì¼ ë¬¸ì ('0'~'9')

	const char* itemType;  // "weapon", "armor", "item"
	const char* itemName;  // íšë“í•  ì•„ì´í…œ ì´ë¦„
} Chest;

void chest_init(Chest* c , int x , int y , char tile, const char* itemType , const char* itemName);

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\entity\enemy.c
[FILE NAME] enemy.c
------------------------------------------------------------

#include <stdio.h>
#include "enemy.h"
#include "../world/glyph.h"

void enemy_init(Enemy* e, const EnemyConfig* config, int x, int y) {
    if (!config) return;

    e->type = config->tile;
    e->x = x;
    e->y = y;
    e->isAlive = 1;

    e->name = config->name;
    e->glyph = config->glyph;
    e->maxHp = config->maxHp;
    e->hp = config->maxHp;
    
    e->attackMin = config->attackMin;
    e->attackMax = config->attackMax;
    e->defense = config->defense;

    e->dialogues = config->dialogues;
    e->dialogueCount = config->dialogueCount;
    e->dialogueIndex = 0;
    e->dialogueColor = config->dialogueColor;
}

int enemy_is_at(const Enemy* e, int x, int y) {
    return (e->isAlive && e->x == x && e->y == y);
}

------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\entity\enemy.h
[FILE NAME] enemy.h
------------------------------------------------------------

#ifndef ENEMY_H
#define ENEMY_H

#include "../stages/common.h"

#define MAX_ENEMIES 50  // ë§µë‹¹ ìµœëŒ€ ì  ìˆ˜

typedef struct {
	char type;      // ì¢…ë¥˜ ('a': ê³ ë¸”ë¦°, 'b': ìŠ¬ë¼ì„, ...)
	int x, y;       // ìœ„ì¹˜
	int isAlive;

	// ìŠ¤íƒ¯
	const char* name;
    const char* glyph;
	int maxHp;
	int hp;
	//int attack;
	int attackMin;
	int attackMax;
	int defense;

	// ëŒ€ì‚¬
	const char** dialogues; // ë¬¸ìì—´ ë°°ì—´ í¬ì¸í„°
	int dialogueCount;
	int dialogueIndex;      // í˜„ì¬ ëŒ€ì‚¬ ì¸ë±ìŠ¤
	
    // ë Œë”ë§
    const char* dialogueColor; // ìƒ‰ìƒ ì½”ë“œ ì¶”ê°€

} Enemy;

// ì´ˆê¸°í™”
void enemy_init(Enemy* e, const EnemyConfig* config, int x, int y);

int enemy_is_at(const Enemy* e, int x, int y);

#endif
#pragma once


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\entity\npc.c
[FILE NAME] npc.c
------------------------------------------------------------

#include <stdio.h>
#include "npc.h"
#include "../world/glyph.h"

void npc_init(NPC* npc, const NPCConfig* config, int x, int y) {
    if (!config) return;

    npc->type = config->tile;
    npc->x = x;
    npc->y = y;
    npc->currentDialogue = 0;

    npc->name = config->name;
    npc->glyph = config->glyph;
    npc->dialogues = config->dialogues;
    npc->dialogueCount = config->dialogueCount;
    npc->canTrade = config->canTrade;
    npc->shopType = config->shopType;
    npc->useDialogueBox = config->useDialogueBox;
}

int npc_is_at(const NPC* npc, int x, int y) {
    return (npc->x == x && npc->y == y);
}

const char* npc_get_dialogue(NPC* npc) {
    if (!npc->dialogues || npc->dialogueCount == 0) return "...";
    return npc->dialogues[npc->currentDialogue];
}

void npc_next_dialogue(NPC* npc) {
    if (npc->dialogueCount > 0) {
        npc->currentDialogue = (npc->currentDialogue + 1) % npc->dialogueCount;
    }
}

------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\entity\npc.h
[FILE NAME] npc.h
------------------------------------------------------------

#pragma once
// src/entity/npc.h - ìƒˆ íŒŒì¼ ìƒì„±

#ifndef NPC_H
#define NPC_H

#include "../stages/common.h"

#define MAX_NPCS 20
#define MAX_NPC_DIALOGUES 10

typedef struct {
	int x , y;
	char type;              // 'A', 'B', 'C' ë“±
	const char* name;       // "ìƒì¸", "ê²½ë¹„ì›" ë“±
	const char* glyph;      // ë Œë”ë§ìš© ë¬¸ì

	// ëŒ€í™” ì‹œìŠ¤í…œ
	const char** dialogues;
	int dialogueCount;
	int currentDialogue;    // í˜„ì¬ ëŒ€í™” ì¸ë±ìŠ¤

	// â˜… ëŒ€í™” ëª¨ë“œ ì¶”ê°€
	int useDialogueBox;    // 1 = ì „ìš© ëŒ€í™”ì°½ ì‚¬ìš©, 0 = ë¡œê·¸ì°½ë§Œ

	// í–¥í›„ í™•ì¥ìš©
	int canTrade;          // ê±°ë˜ ê°€ëŠ¥ ì—¬ë¶€
	const char* shopType;  // "weapon", "armor", "item" ë“±
} NPC;
// ì´ˆê¸°í™”
void npc_init(NPC* npc, const NPCConfig* config, int x, int y);
int npc_is_at(const NPC* npc , int x , int y);
const char* npc_get_dialogue(NPC* npc);
void npc_next_dialogue(NPC* npc);

#endif

------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\entity\player.c
[FILE NAME] player.c
------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>  // â˜… rand() ì‚¬ìš©
#include <time.h>    // â˜… time() ì‚¬ìš©

#include "../world/map.h"
#include "player.h"
#include "../core/ui/ui.h"  // â˜… ui_add_log ì‚¬ìš©ì„ ìœ„í•´ ì¶”ê°€
#include "../core/logic/combat.h"  // â˜… ì¶”ê°€

void player_init(Player* p) {
    // â˜… ë§µ í¬ê¸°ë¥¼ ì•Œ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ê¸°ë³¸ê°’ ì„¤ì •
    p->x = 20;  // ë˜ëŠ” map_init í›„ì— ì„¤ì •
    p->y = 10;

    p->dirX = 0;
    p->dirY = 1;   // ì•„ë˜ ë°©í–¥ì„ ê¸°ë³¸ê°’

    // â˜… ì´ˆê¸° ìŠ¤íƒ¯
    p->maxHp = 10;
    p->hp = 10;
    //p->attack = 3;

    // â˜… ê³µê²©ë ¥ ë²”ìœ„ ì„¤ì •
    p->attackMin = 2;
    p->attackMax = 5;

    p->defense = 0;

    p->weaponName = "";
    p->armorName = "";
    p->item1 = "";
}


void player_move(Player* p, const Map* m, int cmd) {
    int nx = p->x;
    int ny = p->y;

    switch (cmd) {
    case 'w':
        p->dirX = 0; p->dirY = -1;
        ny--;
        break;

    case 's':
        p->dirX = 0; p->dirY = 1;
        ny++;
        break;

    case 'a':
        p->dirX = -1; p->dirY = 0;
        nx--;
        break;

    case 'd':
        p->dirX = 1;  p->dirY = 0;
        nx++;
        break;
    }

    // â˜… ëª©í‘œ ìœ„ì¹˜ì— ì ì´ ìˆëŠ”ì§€ í™•ì¸
    Enemy* targetEnemy = map_get_enemy_at((Map*)m, nx, ny);

    if (targetEnemy != NULL) {
        // â˜… ì ì´ ìˆìœ¼ë©´ ì „íˆ¬!
        combat_attack_enemy(p, targetEnemy, (Map*)m);
        return;  // ì´ë™í•˜ì§€ ì•ŠìŒ
    }

    // ì¼ë°˜ ì´ë™
    if (map_is_walkable(m, nx, ny)) {
        p->x = nx;
        p->y = ny;
    }
}

void player_apply_item(Player* p, const char* itemType, const char* itemName) {

    // ======== ë¬´ê¸° ì ìš© ========
    if (strcmp(itemType, "weapon") == 0) {
        p->weaponName = itemName;

        // ë¬´ê¸° ì¢…ë¥˜ë³„ ëŠ¥ë ¥ì¹˜ ì„¤ì •
        if (strcmp(itemName, "ì´ˆë³´ì ê²€") == 0) {
            p->attackMin = 1000;
            p->attackMax = 10000;
        }
        else if (strcmp(itemName, "ê°•ì²  ê²€") == 0) {
            p->attackMin = 20;
            p->attackMax = 150;
        }
        else if (strcmp(itemName, "ë§ˆë ¥ì˜ ê²€") == 0) {
            p->attackMin = 50;
            p->attackMax = 200;
        }

        ui_add_log("ë¬´ê¸°ë¥¼ ì¥ì°©í–ˆë‹¤!");
        return;
    }

    // ======== ë°©ì–´êµ¬ ì ìš© ========
    if (strcmp(itemType, "armor") == 0) {
        p->armorName = itemName;

        if (strcmp(itemName, "ê°€ì£½ ê°‘ì˜·") == 0)
            p->defense = 2;
        else if (strcmp(itemName, "ì²  ê°‘ì˜·") == 0)
            p->defense = 5;
        else if (strcmp(itemName, "ë§ˆë‚˜ ê°‘ì˜·") == 0)
            p->defense = 10;

        ui_add_log("ë°©ì–´êµ¬ë¥¼ ì°©ìš©í–ˆë‹¤!");
        return;
    }

    // ======== ì•„ì´í…œ ì ìš© (ì˜êµ¬ ë²„í”„ ë²„ì „) ========
    if (strcmp(itemType, "item") == 0) {
        if (strcmp(itemName, "HP í¬ì…˜") == 0) {
            p->hp += 10;
            if (p->hp > p->maxHp) p->hp = p->maxHp;
        }
        else if (strcmp(itemName, "í˜ì˜ ë¬¼ì•½") == 0) {
            p->attackMin += 2;
            p->attackMax += 2;
        }
        else if (strcmp(itemName, "ë¯¼ì²©ì˜ ë¬¼ì•½") == 0) {
            p->defense += 1;
        }

        ui_add_log("ì•„ì´í…œ íš¨ê³¼ê°€ ì ìš©ë˜ì—ˆë‹¤!");
        return;
    }
}


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\entity\player.h
[FILE NAME] player.h
------------------------------------------------------------

#ifndef PLAYER_H
#define PLAYER_H

struct Map;

typedef struct {
	int x , y;

	int dirX;
	int dirY;

	int hp;
	int maxHp;
	//int attack;

	// â˜… ê³µê²©ë ¥ì„ ë²”ìœ„ë¡œ ë³€ê²½
	int attackMin;
	int attackMax;

	int defense;

	const char* weaponName;
	const char* armorName;
	const char* item1;

} Player;

void player_init(Player* p);
void player_move(Player* p , struct Map* m , int cmd);  // â˜… const ì œê±°

#endif

------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\stages\common.h
[FILE NAME] common.h
------------------------------------------------------------

#ifndef STAGE_COMMON_H
#define STAGE_COMMON_H

#include "../cinematic/cinematic.h"

// ============================================
// ê³µí†µ ë°ì´í„° êµ¬ì¡°ì²´ ì •ì˜
// ============================================

// --- Tile Definition (Global Palette) ---
typedef struct {
    char symbol;          // ë§µ ë¬¸ì (ì˜ˆ: '#')
    const char* glyph;    // ê¸€ë¦¬í”„ ë¬¸ìì—´ (ì˜ˆ: GLYPH_WALL_GRAY)
    int walkable;         // 1 = ì´ë™ ê°€ëŠ¥, 0 = ì´ë™ ë¶ˆê°€
    const char* desc;     // ì„¤ëª… (ë””ë²„ê¹…ìš©)
} TileDef;

// --- Chest Definition ---
typedef struct {
    char tile;              // '0', '1', '2' ... (ë§µìƒì˜ ìˆ«ì)
    const char* itemType;   // "weapon", "armor", "item"
    const char* itemName;   // ì•„ì´í…œ ì´ë¦„
} ChestConfig;

// --- Enemy Definition ---
typedef struct {
    char tile;              // 'a', 'b'... (ë§µìƒì˜ ë¬¸ì)
    const char* name;       // ëª¬ìŠ¤í„° ì´ë¦„
    const char* glyph;      // e.g. "ğŸˆ"
    int maxHp;
    int attackMin;
    int attackMax;
    int defense;
    
    // ëŒ€ì‚¬ ê´€ë ¨
    const char** dialogues;
    int dialogueCount;
    const char* dialogueColor; // ì˜ˆ: COLOR_RED (ANSI Code)
} EnemyConfig;

// --- NPC Definition ---
typedef struct {
    char tile;              // 'A', 'B', 'C'...
    const char* name;
    const char* glyph;      // e.g. GLYPH_NPC_MERCHANT
    
    const char** dialogues;
    int dialogueCount;
    
    int canTrade;
    const char* shopType;
    int useDialogueBox;
} NPCConfig;

// --- Stage Definition ---
typedef struct {
    int stageId;
    
    // ë§µ ë°ì´í„°
    const char** mapLines;
    int mapHeight;
    // widthëŠ” strlen(mapLines[0])ìœ¼ë¡œ ê³„ì‚° ê°€ëŠ¥

    // ìƒì ë°ì´í„°
    const ChestConfig* chests;
    int chestCount;

    // ì  ë°ì´í„°
    const EnemyConfig* enemies;
    int enemyCount;

    // NPC ë°ì´í„°
    const NPCConfig* npcs;
    int npcCount;

    // ì‹œë„¤ë§ˆí‹± (ìŠ¤í† ë¦¬)
    const Cinematic* intro;       // ìŠ¤í…Œì´ì§€ ì‹œì‘ ì‹œ ì¬ìƒ
    const Cinematic* outro;       // ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´ ì‹œ ì¬ìƒ
} StageData;

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\stages\stage_01\stage_01.c
[FILE NAME] stage_01.c
------------------------------------------------------------

#include "stage_01.h"
#include <stdlib.h>
#include "../../world/glyph.h"

// ============================================
// Stage 1 Map Data
// ============================================
static const char* MAP_LINES[] = {
"########################################################################################################################",
"########################################################################################################################",
"############..........@.........##############..........###########....................###############################",
"############..................0.##############..........###########....................###############################",
"############....................##############..........###########....................###############################",
"############..........A.........##############..........###########....................###############################",
"############....................##############..........###########....................###############################",
"############....................##############..........###########....................###############################",
"############....................##############..........###########....................###############################",
"############....................##############..........###########....................###############################",
"############....................##############..........###########....................###############################",
"############....................##############..........###########....................###############################",
"############....................##############..........###########....................###############################",
"############....................##############..........###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########............A.......###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.............###########.......................###########....................###############################",
"########.....a.......###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########......b.............###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................###########....................###############....###########",
"########.............###########.......................##.....####....................###############....###########",
"########...............................................##.###.####....................###############....###########",
"########..................................................###.####....................###############....###########",
"########...............................................######.####....................###############....###########",
"########...............................................######.####....................###############....###########",
"########...............................................######....#....................###############....###########",
"########...............................................#########.#....................###############....###########",
"########...............................................#########......................###############....###########",
"########...............................................###########....................###############....###########",
"########...............................................###########....................###############....###########",
"########...............................................###########....................###############....###########",
"########...............................................###########....................###############....###########",
"###############.................#######################################################################....########",
"###############.................#######################################################################....########",
"###############.................#######################################################################....########",
"###############.................#######################################################################....########",
"###############.................########################C##############################################....########",
"###############.................########################.##############################################....########",
"###############.................########################.##############################################....########",
"###############.................########################.##############################################....########",
"###############.................########################.##############################################....########",
"###############..........................................##############################################....########",
"###############....c............########################.##############################################....########",
"###############.................########################.##############################################....########",
"###############.................########################.##############################################....########",
"###############.................########################.##############################################....########",
"########################################################################################################################",
"########################################################################################################################"
};

// ============================================
// Stage 1 Chests
// ============================================
static const ChestConfig CHESTS[] = {
    {'0', "weapon", "ì´ˆë³´ì ê²€"},
    {'1', "armor",  "ê°€ì£½ ê°‘ì˜·"},
    {'2', "item",   "HP í¬ì…˜"},
    {'3', "item",   "ë¯¼ì²©ì˜ ë¬¼ì•½"},
    {'4', "item",   "í˜ì˜ ë¬¼ì•½"},
};

// ============================================
// Stage 1 Enemies
// ============================================

// Type 'a': ë§¹í˜¹í•œê³ ì–‘ì´
static const char* DIALOGUES_A[] = {
    "ë‚˜ëŠ” ì”ì¸í•œ ëƒ¥ì½”ë‹¤ì˜¹",
    "ëƒ¥ì½”ëƒ¥ì½” ëŒ€ì „ìŸ"
};

// Type 'b': ê²½ë¹„ë¡œë´‡
static const char* DIALOGUES_B[] = {
    "ì „ì² ì—­ ë‚´ ì¹¨ì…ìë¥¼ ì¸ì‹í–ˆìŠµë‹ˆë‹¤...",
    "ê²½ê³ : ë¹„ì¸ê°€ ì¸ì›ì…ë‹ˆë‹¤.",
    "ëŒì•„ê°€ë¼ ë‚  ê±´ë“¤ë©´ í›„íšŒí• ê²ƒì´ë‹¤"
};

static const EnemyConfig ENEMIES[] = {
    {
        'a', "ë§¹í˜¹í•œê³ ì–‘ì´", "ğŸˆ",
        5,              // maxHp
        1, 3,           // attackMin, Max
        0,              // defense
        DIALOGUES_A,
        sizeof(DIALOGUES_A) / sizeof(DIALOGUES_A[0]),
        COLOR_BRIGHT_CYAN
    },
    {
        'b', "ê²½ë¹„ë¡œë´‡", COLOR_RED "ğŸ¤–" COLOR_RESET,
        10,
        100, 100,
        0,
        DIALOGUES_B,
        sizeof(DIALOGUES_B) / sizeof(DIALOGUES_B[0]),
        COLOR_RED
    }
};

// ============================================
// Stage 1 NPCs
// ============================================

// A: Merchant
static const char* NPC_DIALOGUES_A[] = {
    "ë‹¹ì‹ ì€ ì´ì œ ì´ê³³ì—ì„œ ëª¨í—˜ì„ ì‹œì‘í•˜ê²Œ ë©ë‹ˆë‹¤.. ",
    "ì´ê³³ì€ ì„±ê· ê´€ëŒ€ì—­ì…ë‹ˆë‹¤.",
    "ë‹¹ì‹ ì€ ì´ ëª¨í—˜ì„ ëë‚´ê³  ì§‘ìœ¼ë¡œ ëŒì•„ê°€ê¸° ìœ„í•´ì„œëŠ” ì˜ë“±í¬ì—­ì— ë„ì°©í•´ì•¼í•©ë‹ˆë‹¤...",
    "ì¼ë‹¨ ì´ ì—­ì˜ ì—­ì¥ì„ ë¬¼ë¦¬ì¹˜ê³  ì˜ì™•ì—­ìœ¼ë¡œ ë„˜ì–´ê°€ì•¼ í•  ê²ƒì…ë‹ˆë‹¤...",
    "í–‰ìš´ì„ ë¹•ë‹ˆë‹¤... í›„í›„í›„..."
};

// C: Citizen
static const char* NPC_DIALOGUES_C[] = {
    "ì•ˆë…•í•˜ì„¸ìš”, ì¢‹ì€ í•˜ë£¨ì…ë‹ˆë‹¤.",
    "ìš”ì¦˜ ì „ì² ì—­ì´ ìœ„í—˜í•˜ë‹¤ê³  í•˜ë”ë¼ê³ ìš”.",
    "ì§€í•˜ì—ëŠ” ì´ìƒí•œ ê²ƒë“¤ì´ ë§ë‹¤ë˜ë°...",
    "ì¡°ì‹¬íˆ ë‹¤ë‹ˆì„¸ìš”!"
};

static const NPCConfig NPCS[] = {
    {
        'A', "ìš°ê±´ë°•", COLOR_BRIGHT_BLUE "ì" COLOR_RESET,
        NPC_DIALOGUES_A, sizeof(NPC_DIALOGUES_A)/sizeof(NPC_DIALOGUES_A[0]),
        0, "general", 1 // canTrade=0 currently but shopType set? Original code had canTrade=0.
    },
    {
        'C', "ì‹œë¯¼", COLOR_BRIGHT_WHITE "ë¯¼" COLOR_RESET,
        NPC_DIALOGUES_C, sizeof(NPC_DIALOGUES_C)/sizeof(NPC_DIALOGUES_C[0]),
        0, NULL, 0
    }
};

// ============================================
// Stage 1 Story (Cinematics)
// ============================================

// --- Intro ---
static const CinematicLine INTRO_LINES[] = {
    { "", STYLE_NORMAL, 300 },
    { "[ STAGE 1 ]", STYLE_TITLE, 500 },
    { "", STYLE_NORMAL, 200 },
    { "ì„±ê· ê´€ëŒ€ì—­", STYLE_SUBTITLE, 800 },
};

static const Cinematic INTRO_CINEMATIC = {
    NULL,
    INTRO_LINES,
    sizeof(INTRO_LINES) / sizeof(INTRO_LINES[0]),
    25,
    1,
    COLOR_YELLOW,
    COLOR_WHITE
};

// --- Outro (Clear) ---
static const CinematicLine CLEAR_LINES[] = {
    { "", STYLE_NORMAL, 300 },
    { "â˜… STAGE CLEAR â˜…", STYLE_TITLE, 800 },
    { "", STYLE_NORMAL, 500 },
    { "ì„±ê· ê´€ëŒ€ì—­ì„ ì •í™”í–ˆë‹¤!", STYLE_TYPEWRITER, 600 },
    { "", STYLE_NORMAL, 300 },
    { "í•˜ì§€ë§Œ ì–´ë‘ ì€ ë” ê¹Šì€ ê³³ì—ì„œ ê¸°ë‹¤ë¦¬ê³  ìˆë‹¤...", STYLE_TYPEWRITER, 0 },
};

static const Cinematic CLEAR_CINEMATIC = {
    NULL,
    CLEAR_LINES,
    sizeof(CLEAR_LINES) / sizeof(CLEAR_LINES[0]),
    30, 
    1, 
    COLOR_BRIGHT_GREEN, 
    COLOR_WHITE
};

// ============================================
// Stage Package
// ============================================
const StageData STAGE_01_DATA = {
    1, // ID
    MAP_LINES,
    sizeof(MAP_LINES) / sizeof(MAP_LINES[0]),
    CHESTS,
    sizeof(CHESTS) / sizeof(CHESTS[0]),
    ENEMIES,
    sizeof(ENEMIES) / sizeof(ENEMIES[0]),
    NPCS,
    sizeof(NPCS) / sizeof(NPCS[0]),
    &INTRO_CINEMATIC,
    &CLEAR_CINEMATIC
};


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\stages\stage_01\stage_01.h
[FILE NAME] stage_01.h
------------------------------------------------------------

#ifndef STAGE_01_H
#define STAGE_01_H

#include "../common.h"

extern const StageData STAGE_01_DATA;

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\stages\stage_02\stage_02.c
[FILE NAME] stage_02.c
------------------------------------------------------------

#include "stage_02.h"
#include <stdlib.h>
#include "../../world/glyph.h"

// ============================================
// Stage 2 Map Data
// ============================================
static const char* MAP_LINES[] = {
    "########################################",
    "#====================================..#",
    "#====================================..#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "#......................................#",
    "########################################"
};

// ============================================
// Stage 2 Chests
// ============================================
static const ChestConfig CHESTS[] = {
    {'0', "weapon", "ê°•ì²  ê²€"},
    {'1', "armor",  "ì²  ê°‘ì˜·"},
    {'2', "item",   "ëŒ€í˜• HP í¬ì…˜"},
    {'3', "item",   "ìŠ¤íƒœë¯¸ë„ˆ ë¬¼ì•½"},
    {'4', "item",   "ì‹ ë¹„í•œ ì›ì„"},
};

// ============================================
// Stage 2 Enemies
// ============================================

// Type 'b': ê²½ë¹„ë¡œë´‡ (Available in Stage 2 context)
static const char* DIALOGUES_B[] = {
    "ì „ì² ì—­ ë‚´ ì¹¨ì…ìë¥¼ ì¸ì‹í–ˆìŠµë‹ˆë‹¤...",
    "ê²½ê³ : ë¹„ì¸ê°€ ì¸ì›ì…ë‹ˆë‹¤.",
    "ëŒì•„ê°€ë¼ ë‚  ê±´ë“¤ë©´ í›„íšŒí• ê²ƒì´ë‹¤"
};

static const EnemyConfig ENEMIES[] = {
    {
        'b', "ê²½ë¹„ë¡œë´‡", COLOR_RED "ğŸ¤–" COLOR_RESET,
        10,
        100, 100,
        0,
        DIALOGUES_B,
        sizeof(DIALOGUES_B) / sizeof(DIALOGUES_B[0]),
        COLOR_RED
    }
};

// ============================================
// Stage 2 Story
// ============================================

static const CinematicLine INTRO_LINES[] = {
    { "", STYLE_NORMAL, 300 },
    { "[ STAGE 2 ]", STYLE_TITLE, 500 },
    { "", STYLE_NORMAL, 200 },
    { "í™”ì„œì—­ í™˜ìŠ¹ í†µë¡œ", STYLE_SUBTITLE, 800 },
    { "", STYLE_NORMAL, 500 },
    { "ë¯¸ë¡œì²˜ëŸ¼ ì–½íŒ í†µë¡œ...", STYLE_TYPEWRITER, 600 },
    { "ë” ê°•ë ¥í•œ ì ë“¤ì´ ê¸°ë‹¤ë¦¬ê³  ìˆë‹¤.", STYLE_TYPEWRITER, 0 },
};

static const Cinematic INTRO_CINEMATIC = {
    NULL,
    INTRO_LINES,
    sizeof(INTRO_LINES) / sizeof(INTRO_LINES[0]),
    25,
    1,
    COLOR_BRIGHT_YELLOW,
    COLOR_WHITE
};

static const CinematicLine CLEAR_LINES[] = {
    { "", STYLE_NORMAL, 300 },
    { "â˜… STAGE CLEAR â˜…", STYLE_TITLE, 800 },
    { "", STYLE_NORMAL, 500 },
    { "í™˜ìŠ¹ í†µë¡œë¥¼ ëŒíŒŒí–ˆë‹¤!", STYLE_TYPEWRITER, 600 },
    { "", STYLE_NORMAL, 300 },
    { "ìµœì¢… ëª©ì ì§€ê°€ ëˆˆì•ì— ìˆë‹¤...", STYLE_TYPEWRITER, 0 },
};

static const Cinematic CLEAR_CINEMATIC = {
    NULL,
    CLEAR_LINES,
    sizeof(CLEAR_LINES) / sizeof(CLEAR_LINES[0]),
    30,
    1,
    COLOR_BRIGHT_GREEN,
    COLOR_WHITE
};

// ============================================
// Stage Package
// ============================================
const StageData STAGE_02_DATA = {
    2,
    MAP_LINES,
    sizeof(MAP_LINES) / sizeof(MAP_LINES[0]),
    CHESTS,
    sizeof(CHESTS) / sizeof(CHESTS[0]),
    ENEMIES,
    sizeof(ENEMIES) / sizeof(ENEMIES[0]),
    NULL, 0, // NPCS
    &INTRO_CINEMATIC,
    &CLEAR_CINEMATIC
};


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\stages\stage_02\stage_02.h
[FILE NAME] stage_02.h
------------------------------------------------------------

#ifndef STAGE_02_H
#define STAGE_02_H

#include "../common.h"

extern const StageData STAGE_02_DATA;

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\stages\stage_03\stage_03.c
[FILE NAME] stage_03.c
------------------------------------------------------------

#include "stage_03.h"
#include <stdlib.h>
#include "../../world/glyph.h"

// ============================================
// Stage 3 Map Data
// ============================================
static const char* MAP_LINES[] = {
    "####################",
    "#..................#",
    "#....####..........#",
    "#....#..#..........#",
    "#....####..........#",
    "#..................#",
    "#..................#",
    "#..................#",
    "#..................#",
    "####################"
};

// ============================================
// Stage 3 Chests
// ============================================
static const ChestConfig CHESTS[] = {
    {'0', "weapon", "ë§ˆë ¥ì˜ ê²€"},
    {'1', "armor",  "ë§ˆë‚˜ ê°‘ì˜·"},
    {'2', "item",   "ìµœëŒ€ HP +5"},
    {'3', "item",   "ê³µê²©ë ¥ +2"},
    {'4', "item",   "ë°©ì–´ë ¥ +2"},
};

// ============================================
// Stage 3 Enemies
// ============================================

// Generic Monster (Default case from original)
static const char* DIALOGUES_M[] = {
    "í‚¤ì—ì—ì—ì—‘!",
    "ìœ¼ë¥´ë¥´ë¥´ë¥´â€¦",
    "ë¼ì•„ì•„ì•…!"
};

static const EnemyConfig ENEMIES[] = {
    {
        'm', "ëª¬ìŠ¤í„°", COLOR_YELLOW "ëª¹" COLOR_RESET,
        3,
        1, 2,
        0,
        DIALOGUES_M,
        sizeof(DIALOGUES_M) / sizeof(DIALOGUES_M[0]),
        COLOR_YELLOW
    }
};

// ============================================
// Stage 3 Story
// ============================================

static const CinematicLine INTRO_LINES[] = {
    { "", STYLE_NORMAL, 300 },
    { "[ STAGE 3 ]", STYLE_TITLE, 500 },
    { "", STYLE_NORMAL, 200 },
    { "ì„œìš¸ì—­ ì§€í•˜ ì‹¬ì¸µë¶€", STYLE_SUBTITLE, 800 },
    { "", STYLE_NORMAL, 500 },
    { "ëª¨ë“  ê²ƒì˜ ì‹œì‘ì ...", STYLE_TYPEWRITER, 600 },
    { "ìµœì¢… ê²°ì „ì´ ê¸°ë‹¤ë¦°ë‹¤.", STYLE_TYPEWRITER, 0 },
};

static const Cinematic INTRO_CINEMATIC = {
    NULL,
    INTRO_LINES,
    sizeof(INTRO_LINES) / sizeof(INTRO_LINES[0]),
    25,
    1, // showSkipHint
    COLOR_BRIGHT_RED, // Border
    COLOR_WHITE
};

static const CinematicLine CLEAR_LINES[] = {
    { "", STYLE_NORMAL, 300 },
    { "â˜… STAGE CLEAR â˜…", STYLE_TITLE, 800 },
    { "", STYLE_NORMAL, 500 },
    { "ëª¨ë“  ì–´ë‘ ì„ ë¬¼ë¦¬ì³¤ë‹¤!", STYLE_TYPEWRITER, 600 },
    { "", STYLE_NORMAL, 300 },
    { "ì„œìš¸ ì§€í•˜ì² ì— ë‹¤ì‹œ í‰í™”ê°€ ì°¾ì•„ì™”ë‹¤.", STYLE_TYPEWRITER, 0 },
};

static const Cinematic CLEAR_CINEMATIC = {
    NULL,
    CLEAR_LINES,
    sizeof(CLEAR_LINES) / sizeof(CLEAR_LINES[0]),
    30,
    1,
    COLOR_BRIGHT_YELLOW,
    COLOR_WHITE
};

// ============================================
// Stage Package
// ============================================
const StageData STAGE_03_DATA = {
    3,
    MAP_LINES,
    sizeof(MAP_LINES) / sizeof(MAP_LINES[0]),
    CHESTS,
    sizeof(CHESTS) / sizeof(CHESTS[0]),
    ENEMIES,
    sizeof(ENEMIES) / sizeof(ENEMIES[0]),
    NULL, 0, // NPCS
    &INTRO_CINEMATIC,
    &CLEAR_CINEMATIC
};


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\stages\stage_03\stage_03.h
[FILE NAME] stage_03.h
------------------------------------------------------------

#ifndef STAGE_03_H
#define STAGE_03_H

#include "../common.h"

extern const StageData STAGE_03_DATA;

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\world\glyph.h
[FILE NAME] glyph.h
------------------------------------------------------------

// src/world/glyph.h - íƒ€ì¼ ì •ì˜ ì¶”ê°€

#ifndef GLYPH_H
#define GLYPH_H

// ========================
// ANSI ìƒ‰ìƒ ì½”ë“œ
// ========================
#define COLOR_RESET   "\033[0m"
#define COLOR_BLACK   "\033[30m"
#define COLOR_RED     "\033[31m"
#define COLOR_GREEN   "\033[32m"
#define COLOR_YELLOW  "\033[33m"
#define COLOR_BLUE    "\033[34m"
#define COLOR_MAGENTA "\033[35m"
#define COLOR_CYAN    "\033[36m"
#define COLOR_WHITE   "\033[37m"
#define COLOR_GRAY    "\033[90m"
#define COLOR_DARK_GRAY "\033[90m"

// ë°ì€ ìƒ‰ìƒ
#define COLOR_BRIGHT_BLACK   "\033[90m"
#define COLOR_BRIGHT_RED     "\033[91m"
#define COLOR_BRIGHT_GREEN   "\033[92m"
#define COLOR_BRIGHT_YELLOW  "\033[93m"
#define COLOR_BRIGHT_BLUE    "\033[94m"
#define COLOR_BRIGHT_MAGENTA "\033[95m"
#define COLOR_BRIGHT_CYAN    "\033[96m"
#define COLOR_BRIGHT_WHITE   "\033[97m"

// ë°°ê²½ìƒ‰
#define BG_BLACK   "\033[40m"
#define BG_RED     "\033[41m"
#define BG_GREEN   "\033[42m"
#define BG_YELLOW  "\033[43m"
#define BG_BLUE    "\033[44m"
#define BG_MAGENTA "\033[45m"
#define BG_CYAN    "\033[46m"
#define BG_WHITE   "\033[47m"

// Bright Backgrounds
#define BG_BRIGHT_BLACK   "\033[100m"
#define BG_BRIGHT_RED     "\033[101m"
#define BG_BRIGHT_GREEN   "\033[102m"
#define BG_BRIGHT_YELLOW  "\033[103m"
#define BG_BRIGHT_BLUE    "\033[104m"
#define BG_BRIGHT_MAGENTA "\033[105m"
#define BG_BRIGHT_CYAN    "\033[106m"
#define BG_BRIGHT_WHITE   "\033[107m"

// ì „íˆ¬ ë©”ì‹œì§€ìš© ìƒ‰ìƒ
#define COMBAT_ATTACK    COLOR_BRIGHT_RED
#define COMBAT_DAMAGE    COLOR_BRIGHT_YELLOW
#define COMBAT_DEATH     COLOR_BRIGHT_MAGENTA
#define COMBAT_ENEMY     COLOR_RED
#define COMBAT_DETECT    COLOR_CYAN

// ë§µ íƒ€ì¼
// ========================
// ë§µ íƒ€ì¼ (ë°°ê²½/êµ¬ì¡°ë¬¼) -> map_data.c ë¡œ ì´ë™ë¨ global palette ì‚¬ìš©

// 5. ìƒì (Chests - map.c ë¡œì§ì—ì„œ ì‚¬ìš©)
#define GLYPH_CHEST_CLOSED   "ğŸ“¦"
#define GLYPH_CHEST_OPEN     "ğŸ“­"

// 6. ì—”í‹°í‹° (Entities)
#define GLYPH_PLAYER   COLOR_BRIGHT_GREEN "ì˜·" COLOR_RESET

// ========================
// í˜¸í™˜ì„± (Compatibility)
// ========================
// (Moved to map_data.c)
#define GLYPH_EMPTY    "  "  // Still used as default fallback in code

// ========================
// íƒ€ì¼ ë¬¸ì (ë§µ ë°ì´í„°ìš©)
// ========================
#define TILE_FLOOR     '.'
// ... (Keep existing TILE_ definitions if useful, or remove if unused)

#endif

------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\world\map.c
[FILE NAME] map.c
------------------------------------------------------------

#include <stdio.h>
#include <windows.h>
#include "map.h"
#include "../entity/player.h"
#include "../entity/enemy.h"  // â˜… ì¶”ê°€
#include "../core/ui/ui.h"   // â˜… ë°˜ë“œì‹œ í•„ìš”
#include "map_data.h"  // â˜… ì¶”ê°€
#include "glyph.h"  // â˜… ì¶”ê°€

// â˜… íƒ€ì¼ ì •ì˜ ì¡°íšŒ Helper
const TileDef* map_get_tile_def(char symbol) {
    for (int i = 0; i < GLOBAL_TILE_PALETTE_COUNT; i++) {
        if (GLOBAL_TILE_PALETTE[i].symbol == symbol) {
            return &GLOBAL_TILE_PALETTE[i];
        }
    }
    return NULL;
}

// íƒ€ì¼ ë¬¸ìë¥¼ ë Œë”ë§ ë¬¸ìë¡œ ë³€í™˜
const char* tile_to_glyph(char t) {
    const TileDef* def = map_get_tile_def(t);
    if (def) {
        return def->glyph;
    }
    return GLYPH_EMPTY;
}


// â˜… ìŠ¤í° í¬ì¸íŠ¸ ì°¾ê¸°
void map_find_spawn(Map* m) {
    // ê¸°ë³¸ê°’ (ì¤‘ì•™)
    m->spawnX = m->width / 2;
    m->spawnY = m->height / 2;

    // @ ì°¾ê¸°
    for (int y = 0; y < m->height; y++) {
        for (int x = 0; x < m->width; x++) {
            if (m->tiles[y][x] == '@') {
                m->spawnX = x;
                m->spawnY = y;
                // @ ë¥¼ ì¼ë°˜ ë°”ë‹¥ìœ¼ë¡œ ë³€í™˜
                m->tiles[y][x] = '.';
                return;  // ì²« ë²ˆì§¸ @ ë§Œ ì‚¬ìš©
            }
        }
    }
}

int is_enemy_tile(char t) {
    return (t == 'a' || t == 'b');   // ëª¬ìŠ¤í„° ëª©ë¡ ì§€ì •
}

// â˜… ë§µì—ì„œ ì  ì°¾ì•„ì„œ ì´ˆê¸°í™”
// â˜… ë§µì—ì„œ ì  ì°¾ì•„ì„œ ì´ˆê¸°í™”
void map_load_enemies(Map* m) {
    m->enemyCount = 0;
    
    const StageData* stageData = get_stage_data(m->stageNumber);
    if (!stageData) return;

    for (int y = 0; y < m->height; y++) {
        for (int x = 0; x < m->width; x++) {
            char tile = m->tiles[y][x];

            // Check against defined enemies for this stage
            for (int i = 0; i < stageData->enemyCount; i++) {
                if (stageData->enemies[i].tile == tile) {
                     if (m->enemyCount < MAX_ENEMIES) {
                        enemy_init(&m->enemies[m->enemyCount], &stageData->enemies[i], x, y);
                        m->enemyCount++;

                        // ì ì´ ìˆë˜ ìë¦¬ëŠ” ë°”ë‹¥ìœ¼ë¡œ ë³€ê²½
                        m->tiles[y][x] = '.';
                    }
                    break;
                }
            }
        }
    }
}

// â˜… íŠ¹ì • ìœ„ì¹˜ì— ìˆëŠ” ì  ë°˜í™˜
Enemy* map_get_enemy_at(Map* m, int x, int y) {
    for (int i = 0; i < m->enemyCount; i++) {
        if (enemy_is_at(&m->enemies[i], x, y)) {
            return &m->enemies[i];
        }
    }
    return NULL;
}

void map_load_chests(Map* m) {
    m->chestCount = 0;

    int cfgCount = 0;
    const ChestConfig* cfg = get_chest_config(m->stageNumber, &cfgCount);

    if (cfg == NULL) return;

    for (int y = 0; y < m->height; y++) {
        for (int x = 0; x < m->width; x++) {

            char tile = m->tiles[y][x];

            // ìƒì íƒ€ì¼ì´ ì•„ë‹Œ ê²½ìš° skip
            if (tile < '0' || tile > '9') continue;

            // í•´ë‹¹ tileì˜ config ì°¾ê¸°
            for (int i = 0; i < cfgCount; i++) {
                if (cfg[i].tile == tile) {

                    chest_init(
                        &m->chests[m->chestCount],
                        x, y,
                        tile,  // â˜… Pass the tile character
                        cfg[i].itemType,
                        cfg[i].itemName
                    );
                    m->chestCount++;

                    //m->tiles[y][x] = '.'; // ìƒì íƒ€ì¼ì„ ë°”ë‹¥ìœ¼ë¡œ ë³€ê²½
                    break;
                }
            }
        }
    }
}






// -------------------------------
// ë§µ ë Œë”ë§
// -------------------------------
//void map_draw(const Map* m, const Player* p) {
//    for (int y = 0; y < MAP_H; y++) {
//        for (int x = 0; x < MAP_W; x++) {
//
//            if (p->x == x && p->y == y) {
//                // í”Œë ˆì´ì–´ ìœ„ì¹˜
//                printf(">>");   // ì „ê° í”Œë ˆì´ì–´ ì•„ì´ì½˜
//            }
//            else {
//                printf("%s", tile_to_glyph(m->tiles[y][x]));
//            }
//
//        }
//        putchar('\n');
//    }
//}



// â˜… map_is_walkable ìˆ˜ì • - NPCë„ ì´ë™ ë¶ˆê°€
int map_is_walkable(const Map* m, int x, int y) {
    if (x < 0 || x >= m->width || y < 0 || y >= m->height)
        return 0;

    char t = m->tiles[y][x];

    // ìƒì(ìˆ«ì)ëŠ” ì´ë™ ë¶ˆê°€
    if (t >= '0' && t <= '9')
        return 0;

    // NPCê°€ ìˆëŠ” ìœ„ì¹˜ëŠ” ì´ë™ ë¶ˆê°€
    for (int i = 0; i < m->npcCount; i++) {
        if (m->npcs[i].x == x && m->npcs[i].y == y)
            return 0;
    }

    // ê¸°ë³¸ íƒ€ì¼ ì´ë™ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
    const TileDef* def = map_get_tile_def(t);
    if (def) {
        return def->walkable;
    }

    return 0;
}


// â˜… í”Œë ˆì´ì–´ ì£¼ë³€(ìƒí•˜ì¢Œìš°)ì— ì ì´ ìˆëŠ”ì§€ í™•ì¸
Enemy* map_get_adjacent_enemy(Map* m, int px, int py) {
    // ìƒí•˜ì¢Œìš° 4ë°©í–¥ ì²´í¬
    int directions[4][2] = {
        {0, -1},  // ìœ„
        {0, 1},   // ì•„ë˜
        {-1, 0},  // ì™¼ìª½
        {1, 0}    // ì˜¤ë¥¸ìª½
    };

    for (int i = 0; i < 4; i++) {
        int nx = px + directions[i][0];
        int ny = py + directions[i][1];

        Enemy* enemy = map_get_enemy_at(m, nx, ny);
        if (enemy != NULL) {
            return enemy;
        }
    }

    return NULL;
}

// â˜… ì ì´ ì–´ëŠ ë°©í–¥ì— ìˆëŠ”ì§€ ë°˜í™˜
const char* map_get_enemy_direction(Map* m, int px, int py, Enemy* enemy) {
    if (enemy->x < px) return "ì™¼ìª½";
    if (enemy->x > px) return "ì˜¤ë¥¸ìª½";
    if (enemy->y < py) return "ìœ„";
    if (enemy->y > py) return "ì•„ë˜";
    return "ì—¬ê¸°";
}

Chest* map_get_chest_at(Map* m, int x, int y) {
    for (int i = 0; i < m->chestCount; i++) {
        if (m->chests[i].x == x && m->chests[i].y == y) {
            return &m->chests[i];
        }
    }
    return NULL;
}

Chest* map_get_adjacent_chest(Map* m, int px, int py) {
    int dirs[4][2] = {
        {0,-1}, {0,1}, {-1,0}, {1,0}
    };

    for (int i = 0; i < 4; i++) {
        int nx = px + dirs[i][0];
        int ny = py + dirs[i][1];

        Chest* chest = map_get_chest_at(m, nx, ny);
        if (chest != NULL) return chest;
    }

    return NULL;
}


// -------------------------------
// ë§µ ì´ˆê¸°í™”
// -------------------------------
void map_init(Map* m, int stageNumber) {
    m->stageNumber = stageNumber;  // â˜… ì„ íƒì‚¬í•­
    load_map(m, stageNumber);

    map_find_spawn(m);  // â˜… ì´ ì¤„ ì¶”ê°€!
    //map_load_enemies(m);  // â˜… ì´ ì¤„ ì¶”ê°€!

    map_load_enemies(m);
    map_load_chests(m);
    map_load_npcs(m);  // â˜… ì¶”ê°€
}


// â˜… map_draw_viewport ìˆ˜ì • - NPC ë Œë”ë§ ì¶”ê°€
void map_draw_viewport(const Map* m, const Player* p,
    int startX, int startY,
    int viewW, int viewH)
{
    int viewX = p->x - viewW / 2;
    int viewY = p->y - viewH / 2;

    if (viewX < 0) viewX = 0;
    if (viewY < 0) viewY = 0;
    if (viewX + viewW > m->width)  viewX = m->width - viewW;
    if (viewY + viewH > m->height) viewY = m->height - viewH;
    if (viewX < 0) viewX = 0;
    if (viewY < 0) viewY = 0;

    for (int sy = 0; sy < viewH; sy++) {
        int my = viewY + sy;
        int screenY = startY + sy;
        
        for (int sx = 0; sx < viewW; sx++) {
            int mx = viewX + sx;
            int screenX = startX + sx * 2; // Assuming 2 chars per tile

            if (mx < 0 || mx >= m->width ||
                my < 0 || my >= m->height)
            {
                ui_draw_str_at(screenX, screenY, "  ", NULL);
                continue;
            }

            // í”Œë ˆì´ì–´ ì¶œë ¥
            if (mx == p->x && my == p->y) {
                ui_draw_str_at(screenX, screenY, GLYPH_PLAYER, NULL);
                continue;
            }

            // â˜… NPC ì¶œë ¥ (ìš°ì„ ìˆœìœ„ ë†’ìŒ)
            NPC* npc = map_get_npc_at((Map*)m, mx, my);
            if (npc != NULL) {
                ui_draw_str_at(screenX, screenY, npc->glyph, NULL);
                continue;
            }

            // ì  ì¶œë ¥
            Enemy* enemy = map_get_enemy_at((Map*)m, mx, my);
            if (enemy != NULL) {
                ui_draw_str_at(screenX, screenY, enemy->glyph, NULL);
                continue;
            }

            // ìƒì ì¶œë ¥
            // ìƒì ì¶œë ¥
            Chest* chest = map_get_chest_at((Map*)m, mx, my);
            if (chest != NULL) {
                if (chest->isOpened) {
                     ui_draw_str_at(screenX, screenY, GLYPH_CHEST_OPEN, NULL);
                } else {
                    // Use the tile stored in the chest to look up the glyph
                    const TileDef* def = map_get_tile_def(chest->tile);
                    if (def) {
                        ui_draw_str_at(screenX, screenY, def->glyph, NULL);
                    } else {
                        ui_draw_str_at(screenX, screenY, GLYPH_CHEST_CLOSED, NULL); // Fallback
                    }
                }
                continue;
            }

            // ê¸°ë³¸ íƒ€ì¼ ì¶œë ¥
            ui_draw_str_at(screenX, screenY, tile_to_glyph(m->tiles[my][mx]), NULL);
        }
    }
}

// src/world/map.c - NPC ê´€ë ¨ í•¨ìˆ˜ ì¶”ê°€

// ê¸°ì¡´ ì½”ë“œ ìœ ì§€í•˜ê³  ì•„ë˜ í•¨ìˆ˜ë“¤ ì¶”ê°€

// â˜… ë§µì—ì„œ NPC ì°¾ì•„ì„œ ì´ˆê¸°í™”
void map_load_npcs(Map* m) {
    m->npcCount = 0;
    
    const StageData* stageData = get_stage_data(m->stageNumber);
    if (!stageData) return;

    for (int y = 0; y < m->height; y++) {
        for (int x = 0; x < m->width; x++) {
            char tile = m->tiles[y][x];

            for (int i = 0; i < stageData->npcCount; i++) {
                if (stageData->npcs[i].tile == tile) {
                    if (m->npcCount < MAX_NPCS) {
                        npc_init(&m->npcs[m->npcCount], &stageData->npcs[i], x, y);
                        m->npcCount++;

                        // NPCê°€ ìˆë˜ ìë¦¬ëŠ” ë°”ë‹¥ìœ¼ë¡œ ë³€ê²½
                        m->tiles[y][x] = '.';
                    }
                    break;
                }
            }
        }
    }
}

// â˜… íŠ¹ì • ìœ„ì¹˜ì— ìˆëŠ” NPC ë°˜í™˜
NPC* map_get_npc_at(Map* m, int x, int y) {
    for (int i = 0; i < m->npcCount; i++) {
        if (npc_is_at(&m->npcs[i], x, y)) {
            return &m->npcs[i];
        }
    }
    return NULL;
}

// â˜… í”Œë ˆì´ì–´ ì¸ì ‘í•œ NPC ì°¾ê¸°
NPC* map_get_adjacent_npc(Map* m, int px, int py) {
    int dirs[4][2] = {
        {0, -1}, {0, 1}, {-1, 0}, {1, 0}
    };

    for (int i = 0; i < 4; i++) {
        int nx = px + dirs[i][0];
        int ny = py + dirs[i][1];

        NPC* npc = map_get_npc_at(m, nx, ny);
        if (npc != NULL) return npc;
    }

    return NULL;
}

------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\world\map.h
[FILE NAME] map.h
------------------------------------------------------------

#ifndef MAP_HEADER
#define MAP_HEADER

#include "../entity/player.h"
#include "../entity/enemy.h"  // â˜… ì¶”ê°€
#include "../entity/chest.h"
#include "../entity/npc.h"  // â˜… ì¶”ê°€

#define MAX_MAP_W 200  // ìµœëŒ€ í¬ê¸°ë§Œ ì •ì˜
#define MAX_MAP_H 120
#define MAX_CHESTS 50

typedef struct {
	int width;
	int height;
	int stageNumber;  // â˜… í˜„ì¬ ìŠ¤í…Œì´ì§€ ë²ˆí˜¸ ì¶”ê°€ (ì„ íƒì‚¬í•­)
	int spawnX;  // â˜… ìŠ¤í° ìœ„ì¹˜ ì¶”ê°€
	int spawnY;  // â˜… ìŠ¤í° ìœ„ì¹˜ ì¶”ê°€
	char tiles[ MAX_MAP_H ][ MAX_MAP_W ];

	// â˜… ì  ê´€ë¦¬
	Enemy enemies[ MAX_ENEMIES ];
	int enemyCount;

	Chest chests[ MAX_CHESTS ];
	int chestCount;

	// â˜… NPC ì¶”ê°€
	NPC npcs[ MAX_NPCS ];
	int npcCount;
} Map;

void map_init(Map* m , int stageNumber);
int map_is_walkable(const Map* m, int x, int y);
const char* tile_to_glyph(char t);
void map_find_spawn(Map* m);
void map_load_enemies(Map* m);
Enemy* map_get_enemy_at(Map* m , int x , int y);
Enemy* map_get_adjacent_enemy(Map* m , int px , int py);
const char* map_get_enemy_direction(Map* m , int px , int py , Enemy* enemy);  // â˜… ì¶”ê°€
const char* enemy_to_glyph(char type);

Chest* map_get_chest_at(Map* m , int x , int y);
Chest* map_get_adjacent_chest(Map* m , int px , int py);

// â˜… NPC ê´€ë ¨ í•¨ìˆ˜
void map_load_npcs(Map* m);
NPC* map_get_npc_at(Map* m , int x , int y);
NPC* map_get_adjacent_npc(Map* m , int px , int py);


void map_draw_viewport(const Map* m , const Player* p , int startX , int startY ,
	int viewW , int viewH);

#endif


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\world\map_data.c
[FILE NAME] map_data.c
------------------------------------------------------------

#include "map_data.h"
#include <string.h>
#include <stdlib.h>

#include "glyph.h"
#include "../stages/stage_01/stage_01.h"
#include "../stages/stage_02/stage_02.h"
#include "../stages/stage_03/stage_03.h"

// ========================
// Global Tile Palette
// ========================
// ========================
// Global Tile Palette
// ========================
const TileDef GLOBAL_TILE_PALETTE[] = {
    // Floors (Walkable)
    { '.', "\033[48;5;240m..\033[0m",   1, "Tiled Floor" },
    { ',', "\033[32m,,\033[0m",        1, "Grass Floor" },
    { '-', "\033[48;5;235m--\033[0m",   1, "Paved Floor" },
    { '_', "\033[93m..\033[0m",        1, "Dirt Floor" },
    { '~', "\033[44m  \033[0m",        1, "Water" },

    // Walls (Blocked)
    { '#', "\033[48;5;236m  \033[0m",  0, "Gray Wall" },
    { '%', "\033[48;5;124m  \033[0m",  0, "Brick Wall" },
    { '&', "\033[48;5;22m  \033[0m",   0, "Iron Wall" },
    { '$', "\033[48;5;123m  \033[0m",  0, "Glass Wall" },
    
    // Objects
    { '+', "ğŸšª",                      0, "Closed Door" },
    { '/', "\033[30mâ–’â–’\033[0m",        1, "Open Door" },
    { 'T', "ğŸŒ²",                      0, "Tree" },
    { 'B', "ğŸš§",                      0, "Barricade" },
    { '=', "||",                      1, "Rail" },
    { 'S', "â–¼â–¼",                      1, "Stairs Down" },
    { 'U', "â–²â–²",                      1, "Stairs Up" },

    // Special
    { '@', "  ",                      1, "Spawn Point" }, // Default floor
    
    // Chests (0-9) - Blocked
    { '0', "ğŸ“¦",  0, "Chest 0" },
    { '1', "ğŸ“¦",  0, "Chest 1" },
    { '2', "ğŸ“¦",  0, "Chest 2" },
    { '3', "ğŸ“¦",  0, "Chest 3" },
    { '4', "ğŸ“¦",  0, "Chest 4" },
    { '5', "ğŸ“¦",  0, "Chest 5" },
    { '6', "ğŸ“¦",  0, "Chest 6" },
    { '7', "ğŸ“¦",  0, "Chest 7" },
    { '8', "ğŸ“¦",  0, "Chest 8" },
    { '9', "ğŸ“¦",  0, "Chest 9" },
};
const int GLOBAL_TILE_PALETTE_COUNT = sizeof(GLOBAL_TILE_PALETTE) / sizeof(GLOBAL_TILE_PALETTE[0]);

// ========================
// ê³µí†µ ë¡œë“œ í•¨ìˆ˜
// ========================
static void load_map_from_lines(Map* m, const char** mapData, int height) {
    m->height = height;
    m->width = strlen(mapData[0]);

    for (int y = 0; y < m->height && y < MAX_MAP_H; y++) {
        for (int x = 0; x < m->width && x < MAX_MAP_W; x++) {
            m->tiles[y][x] = mapData[y][x];
        }
    }
}

// ========================
// ë°ì´í„° ì ‘ê·¼ í•¨ìˆ˜
// ========================

const StageData* get_stage_data(int stageNumber) {
    switch (stageNumber) {
        case 1: return &STAGE_01_DATA;
        case 2: return &STAGE_02_DATA;
        case 3: return &STAGE_03_DATA;
        default: return NULL;
    }
}

void load_map(Map* m, int stageNumber) {
    const StageData* data = get_stage_data(stageNumber);
    if (data) {
        load_map_from_lines(m, data->mapLines, data->mapHeight);
    } else {
        // Fallback or empty map
        // For safety, maybe clear map?
        m->height = 0;
        m->width = 0;
    }
}

const ChestConfig* get_chest_config(int stage, int* outCount) {
    const StageData* data = get_stage_data(stage);
    if (data) {
        *outCount = data->chestCount;
        return data->chests;
    }
    *outCount = 0;
    return NULL;
}


------------------------------------------------------------
[FILE PATH] c:\projects\MetroHero\MetroHero\src\world\map_data.h
[FILE NAME] map_data.h
------------------------------------------------------------

#ifndef MAP_DATA_H
#define MAP_DATA_H

#include "map.h"
#include "../stages/common.h"

// get_chest_config is kept for compatibility but implementation will change
const ChestConfig* get_chest_config(int stage , int* outCount);

// Global Tile Palette
extern const TileDef GLOBAL_TILE_PALETTE[];
extern const int GLOBAL_TILE_PALETTE_COUNT;

const StageData* get_stage_data(int stageNumber);

void load_map(Map* m , int stageNumber);

#endif

=== Source Collection End ===
